# Quick Modern Object Pascal for Programmers
Michalis Kamburelis
:toc:
:toclevels: 4
:sectnums:
:source-highlighter: coderay

## Why

There's a lot of books and resources about Pascal out there, but too many of them talk about the old Pascal, without classes, units or generics.
// Some of them talk about Pascal before it even had classes. Some of them show classes, as done in Delphi, but fail to mention more modern features, like generics.

So I wrote this quick introduction to what I call *modern Object Pascal*. Most of the programmers using it don't really call it _"modern Object Pascal"_, we just call it  _"our Pascal"_. But when introducing the language, I feel it's important to emphasize that it's a modern, object-oriented language. It evolved a *lot* since the old (Turbo) Pascal that many people learned in schools long time ago. Feature-wise, it's quite similar to C++ or Java or C#.

* It has all the modern features you expect -- classes, units, interfaces, generics...
* It's compiled to a fast, native code,
* It's very type safe,
* High-level but can also be low-level if you need it to be.

It also has excellent, portable and open-source compiler called the _Free Pascal Compiler_, http://freepascal.org/ . And an accompanying IDE (editor, debugger, a library of visual components, form designer) called _Lazarus_ http://lazarus.freepascal.org/ . Myself, I'm the creator of _Castle Game Engine_, http://castle-engine.sourceforge.net/ , which is a cool portable 3D and 2D game engine using this language to create games on many platforms (Windows, Linux, MacOSX, Android, iOS, web plugin).

This introduction is mostly directed at programmers who already have experience in other languages. We will not cover here the meanings of some universal concepts, like _"what is a class"_, we'll only show how to do them in Pascal.

## Basics

### "Hello world" program

[source,pascal]
----
include::code-samples/hello_world.lpr[]
----

This is a complete program that you can _compile_ and _run_.

* If you use the command-line FPC, just create a new file `myprogram.lpr` and execute `fpc myprogram.lpr`.
* If you use _Lazarus_, create a new project (menu _Project_ -> _New Project_ -> _Simple Program_). Save it as `myprogram` and paste this source code as the main file. Compile using the menu item _Run -> Compile_.
* This is a command-line program, so in either case -- just run the compiled executable from the command-line.

The rest of this article talks about the Object Pascal language, so don't expect to see anything more fancy than the command-line stuff. If you want to see something cool, just create a new GUI project in _Lazarus_ (_Project_ -> _New Project_ -> _Application_).
//Play around, drop some buttons on the form, handle their events (like `OnClick`).
Voila -- a working GUI application, cross-platform, with native look everywhere, using a comfortable visual component library. The _Lazarus_ and _Free Pascal Compiler_ come with lots of ready units for networking, GUI, database, file formats (XML, json, images...), threading and everything else you may need. I already mentioned my cool _Castle Game Engine_ earlier:)
// The libraries created in other languages (dll, so, dylib) can be easily used from FPC too (and for most of them, you'll find ready "header" units, and even units that wrap them in more modern object-oriented API).

### Functions, procedures, primitive types

[source,pascal]
----
include::code-samples/functions_primitives.lpr[]
----

To return a value from a function, assign something to the magic `Result` variable. You can read and set the `Result` freely, just like a local variable.

[source,pascal]
----
function MyFunction(const S: string): string;
begin
  Result := S + 'something';
  Result := Result + ' something more!';
  Result := Result + ' and more!';
end;
----

You can also treat the function name (like `MyFunction` in example above) as the variable, to which you can assign. But I would discourage it in new code, as it looks "fishy" when used on the right side of the assignment expression. Just use `Result` always when you want to read or set the function result. If you want to call the function itself recursively, you can of course do it, and be sure to specify the parenthesis (this makes a recursive call to parameter-less function different from accessing this function's current result). Like this:

[source,pascal]
----
function ReadIntegersUntilZero: string;
var
  I: Integer;
begin
  Readln(I);
  Result := IntToStr(I);
  if I <> 0 then
    Result := Result + ' ' + ReadIntegersUntilZero();
end;
----

You can call `Exit` to end the execution of the procedure or function before it reaches the final `end;`. If you call parameter-less `Exit` in a function, it wil return the last thing you set as `Result`. You can also use `Exit(X)` construct, to set the function result and exit *now* -- this is just like `return X` construct in C-like languages.

[source,pascal]
----
function AddName(const ExistingNames, NewName: string): string;
begin
  if ExistingNames = '' then
    Exit(NewName);
  Result := ExistingNames + ', ' + NewName;
end;
----

### Enumerated and ordinal types and sets and constant-length arrays

Enumerated type in Pascal is a very nice, opaque type. You will probably use it much more often than enums in other languages:)

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
----

The convention is to prefix the enum names with a two-letter shortcut of type name, hence `ak` = shortcut for _"Animal Kind"_. This is a useful convention, since the enum names are in the unit (global) namespace. So by prefixing them with `ak` prefix, you minimize the chances of collisions with other identifiers.

NOTE: The collisions in names are not a show-stopper. It's Ok for different units to define the same identifier. But it's a good idea to try to avoid the collisions anyway, to keep code simple to understand and grep.

The fact that enumerated type is _opaque_ means that it cannot be just assigned to and from an integer. However, for special use, you can use `Ord(MyAnimalKind)` to forcefully convert enum to int, or typecast `TAnimalKind(MyInteger)` to forcefully convert int to enum. In the latter case, make sure to check first whether `MyInteger` is in good range (0 to `Ord(High(TAnimalKind))`).

Enumerated and ordinal types can be used as array indexes:

[source,pascal]
----
type
  TArrayOfTenStrings = array [0..9] of string;
  TArrayOfTenStrings1Based = array [1..10] of string;

  TMyNumber = 0..9;
  TAlsoArrayOfTenStrings = array [TMyNumber] of string;

  TAnimalKind = (akDuck, akCat, akDog);
  TAnimalNames = array [TAnimalKind] of string;
----

They can also be used to create sets (a bit-fields internally):

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
  TAnimals = set of TAnimalKind;
var
  A: TAnimals;
begin
  A := [];
  A := [akDuck, akCat];
  A := A + [akDog];
  A := A * [akCat, akDog];
  Include(A, akDuck);
  Exclude(A, akDuck);
end;
----

### Output, logging

To simply output strings in Pascal, use the `Write` or `Writeln` routine. The latter automatically adds a newline at the end.

This is "magic" routine in Pascal, it takes a variable number of arguments and they can have any type. They are all converted to strings when displaying, with some special syntax for specifying padding and number precision.

[source,pascal]
----
Writeln('Hello world!');
Writeln('You can output an integer: ', 3 * 4);
Writeln('You can pad an integer: ', 666:10);
Writeln('You can output a float: ', Pi:1:4);
----

To explicitly use newline in string, use the `LineEnding` constant (FPC RTL) (_Castle Game Engine_ has also a shorter `NL` constant). Pascal strings do not interpret any special backslash sequences, so writing

[source,pascal]
----
Writeln('One line.\nSecond line.'); // INCORRECT example
----

doesn't work like some of you would think. This will work:

[source,pascal]
----
Writeln('One line.' + LineEnding + 'Second line.');
----

or just this:

[source,pascal]
----
Writeln('One line.');
Writeln('Second line.');
----

Note that this will only work in _console_ applications. Make sure you have `{$apptype CONSOLE}` (and *not* `{$apptype GUI}`) defined in your main program file. On some operating systems it actually doesn't matter and will work always (Unix), but on some operating systems trying to write something from a GUI application is an error (Windows).

*In Castle Game Engine:* use `WritelnLog`, never `Writeln`. This will be always directed to some useful output. On Unix, standard output. On Windows GUI application, log file. On Android, the _Android logging facility_ (visible when you use `adb logcat`).

## Units

Units allow you to group common stuff (anything that can be declared), for usage by other units and programs. They are equivalent to _modules_ and _packages_ in other languages. They have an interface section, where you declare what is available for other units and programs, and then the implementation. Save unit `MyUnit` as `myunit.pas` (lowercase with `.pas` extension).

[source,pascal]
----
include::code-samples/myunit.pas[]
----

Final programs are saved as `myprogram.lpr` files (`lpr` = Lazarus program file; in Delphi you would use `.dpr`). Note that other conventions are possible here, e.g. some projects just use `.pas` for main program file, some use `.pp` for units or programs. I advice using `.pas` for units and `.lpr` for FPC/Lazarus programs.

A program can use a unit by a `uses` keyword:

[source,pascal]
----
include::code-samples/myunit_test.lpr[]
----

One unit can also use another unit. Another unit can be used in the interface section, or only in the implementation section. The former allows to define new public stuff (procedures, types...) on top of another unit's stuff. The latter is more limited (if you use a unit only in the implementation section, you can use it's identifiers only in your implementation).

[source,pascal]
----
include::code-samples/anotherunit.pas[]
----

It is not allowed to have _circular unit dependencies in the interface_. That is, two units cannot use each other in the interface section. This constraint is reasonable -- in order to "understand" (e.g. decide on a memory layout of structures) the interface section of a unit, the compiler must first "understand" all the units it uses in interface section. With circular dependencies, this would be impossible. (That said, this constraint is not existing in some other languages. You can actually do parsing without "complete understanding" of your dependencies, just some stuff will have to be resolved later, e.g. at linking. You can also "repeat" the compilation until your knowledge is "settled". Anyway, you have to live with this constraint now, and enjoy fast compilation times.:)

It is _OK to make a circular dependency between units when at least one "usage" is only in the implementation_. So it's OK for unit `A` to use unit `B` in the interface, and then unit `B` to use unit `A` in the implementation.

## Classes

### Basics

We have classes. At the basic level, a class is just a container for

* _fields_ (which is fancy name for _"a variable inside a class"_),
* _methods_ (which is fancy name for _"a procedure or function inside a class"_),
* and _properties_ (which is a fancy syntax for something that looks like a field, but is in fact a pair of methods to _get_ and _set_ something).
* Actually, you can put <<More stuff inside classes and nested classes>>, more about this in later section.

[source,pascal]
----
type
  TMyClass = class
    MyInt: Integer;
    procedure MyMethod;
  end;

procedure TMyClass.MyMethod;
begin
  Writeln(MyInt + 10);
end;
----

We have inheritance and virtual methods.

[source,pascal]
----
include::code-samples/inheritance.lpr[]
----

By default methods are not virtual, declare them with `virtual` to make them. Overrides must be marked with `override`, otherwise you will get a warning. To hide a method without overriding (usually you don't want to do this, unless you now what you're doing) use `reintroduce`.

### Properties

Properties are a very nice _"syntax sugar"_ to

1. Make something that looks like a field (can be read and set) but underneath is realized by calling a _getter_ and a _setter_ function. A most typical usage is to perform some side-effect each time some value changes.
2. Make something that looks like a field, but is read-only. In effect, it's like a constant or a parameter-less function.

[source,pascal]
----
type
  TWebPage = class
  private
    FURL: string;
    FColor: TColor;
    function SetColor(const Value: TColor);
  public
    { No way to set it directly.
      Call the Load method, like Load('http://www.freepascal.org/'),
      to load a page and set this property. }
    property URL: string read FURL;
    procedure Load(const AnURL: string);
    property Color: TColor read FColor write SetColor;
  end;

procedure TWebPage.Load(const AnURL: string);
begin
  FURL := AnURL;
  NetworkingComponent.LoadWebPage(AnURL);
end;

function TWebPage.SetColor(const Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    // for example, cause some update each time value changes
    Repaint;
    // as another example, make sure that some underlying instance,
    // like a "RenderingComponent" (whatever that is),
    // has a synchronized value of Color.
    RenderingComponent.Color := Value;
  end;
end;
----

// { compare with the old value, to shield from making
//   useless assignments to RenderingComponent.Color.
//   This is a common approach to guarantee that setting WebPage.Color
//   many times to the same value will be fast,
//   even if setting RenderingComponent.Color many times to the same value
//   would be slow. }

When declaring a property you specify:

. Whether it can be read, and how (by directly reading a field, or by using a "getter" method).
. And, in a similar manner,  whether it can be set, and how (by directly writing to a designated field, or by calling a "setter" method).

The compiler checks that the types and parameters of indicated fields and methods match with the property type. For example, to read an `Integer` property you have to either provide an `Integer` field, or a parameter-less method that returns an `Integer`.

Technically, for the compiler, the "getter" and "setter" methods are just normal methods and they can do absolutely anything (including side-effects or randomization). But it's a good convention to design properties to behave more-or-less like fields:

// There are some good conventions to follow when creating properties. These are only conventions, the compiler doesn't prevent you from making something weird using properties -- f. But the good
// They should be somewhat predictable, like fields:

* The _getter_ function should have no visible side-effects (e.g. it should not read some input from file / keyboard). It should be deterministic (no randomization, not even pseudo-randomization :). Reading a property many times should be valid, and return the same value, if nothing changed in-between.
+
Note that it's OK for _getter_ to have some _invisible_ side-effect, for example to cache a value of some calculation (known to produce the same results for given instance), to return it faster next time. This is in fact one of the cool possibilities of a "getter" function.

* The _setter_ function should always set the requested value, such that calling the _getter_ yields it back. Do not reject invalid values silently in the "setter" (raise an exception if you must). Do not convert or scale the requested value. The idea is that after `MyClass.MyProperty := 123;` the programmer can expect that `MyClass.MyProperty = 123`.

* The _read-only properties_ are often used to make some field read-only from the outside. Again, the good convention is to make it behave like a constant, at least constant for this object instance, at least constant for this object instance with this state. The value of the property should not change unexpectedly. Make it a function, not a property, if reading it has a side effect or returns something random.

* The _"backing" field of a property is almost always private_, since the idea of a property is to encapsulate all outside access to it.

* It's technically possible to make _set-only properties_, but I have not yet seen a good example of such thing:)

NOTE: Properties can also be defined outside of class, at a unit level. They serve an analogous purpose then: look like a global variable, but are backed by a _getter_ and _setter_ routines.

### Exceptions

We have exceptions. They can be caught with `try ... except ... end` clauses, and we have finally sections like `try ... finally ... end`.

[source,pascal]
----
include::code-samples/exception_finally.lpr[]
----

Note that the `finally` clause is executed even if you exit the block using the `Exit` (from function / procedure / method) or `Break` or `Continue` (from loop body).

### Visibility specifiers

As in all object-oriented languages, we have visibility specifiers to hide fields / methods / properties.

The basic visibility levels are:

`public`:: everyone can access it, including the code in other units.
`private`:: only accessible in this class.
`protected`:: only accessible in this class and descendants.

The explanation of `private` and `protected` visibility above is not precisely true. The code _in the same unit_ can overcome their limits, and access the `private` and `protected` stuff freely. Sometimes this is a nice feature, allows you to implement tightly-connected classes. Use `strict private` or `strict protected` to secure your classes more tightly. See <<private and strict private>> section.

By default, if you don't specify the visibility, then the visibility of declared stuff is `public`. The exception is for classes compiled with `{$M+}`, or descendants of classes compiled with `{$M+}`, which includes all descendants of `TPersistent`, which also includes all descendants of `TComponent` (since `TComponent` descends from `TPersistent`). For them, the default visibility specifier is `published`, which is like `public`, but in addition the streaming system knows to handle this.

Not every field and property type is allowed in the `published` section (not every type can be streamed). Just use `public` if you don't care about streaming but want something available to all users.

### Default ancestor

If you don't declare the ancestor type, every `class` inherits from `TObject`.

## Freeing classes

### Remember to free (release memory) class instances

The classes (instances of the `class` type) have to be manually freed, otherwise you get memory leaks. I advice using FPC `-gl -gh` options to detect memory leaks (see http://castle-engine.sourceforge.net/tutorial_optimization.php#section_memory ).

Note that this doesn't concern raised exceptions. Although you do create a class when raising an exception (and it's a perfectly normal class, and you can create your own classes for this purpose too). But this class instance is freed automatically.

### How to free

To free the class instance, it's best to call `FreeAndNil(A)` on your class instance. It checks whether `A` is `nil`, if not -- calls it's destructor, and sets `A` to `nil`. So calling it many times in a row is not an error.

It is more-or-less a shortcut for

[source,pascal]
----
if A <> nil then
begin
  A.Destroy;
  A := nil'
end;
----

Actually, that's an oversimplification, as `FreeAndNil` does a useful trick and sets the variable `A` to `nil` *before* calling the destructor on a suitable reference.

Often in other code you will also find people using the `A.Free` method, which is like doing

[source,pascal]
----
if A <> nil then
  A.Destroy;
----

Note that in normal circumstances, you should never call a method on an instance which may be `nil`. The `Free` method is an exception here (it does something dirty in the implementation -- namely, checks whether `Self <> nil`).

I advice using `FreeAndNil(A)` always, without exceptions, and never to call directly the `Free` method or `Destroy` destructor. _Castle Game Engine_ does it like that. It provides a nice assertion that _all references are either nil, or point to valid instances_.

### Manual and automatic freeing

In many situations, the need to free the instance is not much problem. You just write a destructor, that matches a constructor, and deallocates everything that was allocated in constructor (or, more completely, in the whole lifetime of the class). Be careful to only free each thing *once*. Usually it's a good idea to set the freed reference to `nil`, usually it's most comfortable to do it by calling the `FreeAndNil(A)`.

So, like this:

[source,pascal]
----
uses SysUtils;

type
  TGun = class
  end;

  TPlayer = class
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  Gun1 := TGun.Create;
  Gun2 := TGun.Create;
end;

destructor TPlayer.Destroy;
begin
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  inherited;
end;
----

To avoid the need to explicitly free the instance, one can also use the `TComponent` feature of _"ownership"_. An object that is owned will be automatically freed by the owner. It's automatically taken care of to not free an already freed instance this way (so things will also work correct if you manually free the owned object earlier). We can change the previous example to this:

[source,pascal]
----
uses SysUtils, Classes;

type
  TGun = class(TComponent)
  end;

  TPlayer = class(TComponent)
    Gun1, Gun2: TGun;
    constructor Create(AOwner: TComponent); override;
  end;

constructor TPlayer.Create(AOwner: TComponent);
begin
  inherited;
  Gun1 := TGun.Create(Self);
  Gun2 := TGun.Create(Self);
end;
----

Note that we need to override a virtual `TComponent` constructor here. So we cannot change the constructor parameters. (Actually, you can -- declare a new constructor with `reintroduce`. But be careful, as some functionality, e.g. streaming, will still use the virtual constructor, so make sure it works right in either case.)

Another approach to automatic freeing is use the `OwnsObjects` functionality (by default already `true`!) of list-classes like `TFPGObjectList` or `TObjectList`. So we could also write:

[source,pascal]
----
uses SysUtils, Classes, FGL;

type
  TGun = class
  end;

  TGunList = specialize TFPGObjectList<TGun>;

  TPlayer = class
    Guns: TGunList;
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  // Actually, the parameter true (OwnsObjects) is already the default
  Guns := TGunList.Create(true);
  Gun1 := TGun.Create(Self);
  Guns.Add(Gun1);
  Gun2 := TGun.Create(Self);
  Guns.Add(Gun2);
end;

destructor TPlayer.Destroy;
begin
  { We have to take care to free the list.
    It will automatically free it's contents. }
  FreeAndNil(Guns);

  { No need to free the Gun1, Gun2 anymore. It's a nice habit to set to "nil"
    their references now, as we know they are freed. In this simple class,
    with so simple destructor, it's obvious that they cannot be accessed
    anymore -- but doing this pays off in case of larger and more complicated
    destructors.

    Alternatively, we could avoid declaring Gun1 and Gun2,
    and instead use Guns[0] and Guns[1] in own code.
    Or create a function like Gun1 that returns Guns[0]. }
  Gun1 := nil;
  Gun2 := nil;
  inherited;
end;
----

Beware that the list classes "ownership" mechanism is simple, and you will get an error if you free the instance using some other means. Use `Extract` method to remove something from a list without freeing it, thus taking the responsibility to free it yourself.

*In Castle Game Engine*: The descendants of `TX3DNode` have automatic memory management when inserted as children of another `TX3DNode`. The root X3D node, `TX3DRootNode`, is in turn usually owned by `TCastleSceneCore`. Some other things also have a simple ownership mechanism -- look for parameters and properties called `OwnsXxx`.

### Free notification

If you copy a reference to the instance, such that you have two references to the same memory, and then one of them is freed -- the other one becomes a _"dangling pointer"_. It should not be accessed, as it points to a memory that is no longer allocated. Accessing it may result in a runtime error, or garbage being returned (as the memory may be reused for other stuff in your program).

Using the `FreeAndNil` to free the instance doesn't help here. `FreeAndNil` sets to `nil` only the reference it got -- there's no way for it to set all other references.

[source,pascal]
----
var
  O1, O2: TObject;
begin
  O1 := TObject.Create;
  O2 := O1;
  FreeAndNil(O1);

  { Now O1 is nil. If some code may access it, it can use
    "if O1 <> nil ..." to avoid calling methods on a freed instance,
    like

      if O1 <> nil then Writeln(O1.ClassName);

    Trying to access a field of a nil instance (or call a method
    that accessed a field of a nil instance) results in a predictable
    exception at runtime. }

  { With O2, things are more difficult. It's not nil, but it's invalid.
    Trying to access a field of a nil instance (or call a method
    that accessed a field of a nil instance) results in an unpredictable
    behavior - maybe an access violation exception, maybe a garbage data
    returned. }
end;
----

There are various solutions to it:

* One solution is to, well, be careful. Don't assume anything about the lifetime of the reference, if it's created by other code. If a class `TCar` has a field pointing to some instance of `TWheel`, it's a _convention_ that the reference to _wheel_ is valid as long as the reference to _car_ exists, and the _car_ will free it's _wheels_ inside it's destructor. But that's just a convention, the documentation should mention if there's something more complicated going on.

* The other solution is to use `TComponent` class "free notification" mechanism. One component can be notified when another component is freed, and thus set it's reference to `nil`.
+
Thus you get something like a _weak reference_. It can cope with various usage scenarios, for example you can let the code from outside of the class to set your reference, and the outside code can also free the instance at anytime.
+
This requires both classes to descend from `TComponent`. Using it in general boils down to calling `FreeNotification` , `RemoveFreeNotification`, and overriding `Notification`.
+
Here's a complete example, showing how to use this mechanism, together with constructor / destructor and a setter property. Sometimes it can be done simpler, but this is the full-blown version that is always correct:)
+
[source,pascal]
----
type
  TControl = class(TComponent)
  end;

  TContainer = class(TComponent)
  private
    FSomeSpecialControl: TControl;
    procedure SetSomeSpecialControl(const Value: TControl);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    destructor Destroy; override;
    property SomeSpecialControl: TControl
      read FSomeSpecialControl write SetSomeSpecialControl;
  end;

implementation

procedure TContainer.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSomeSpecialControl) then
    { set to nil by SetSomeSpecialControl to clean nicely }
    SomeSpecialControl := nil;
end;

procedure TContainer.SetSomeSpecialControl(const Value: TControl);
begin
  if FSomeSpecialControl <> Value then
  begin
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.RemoveFreeNotification(Self);
    FSomeSpecialControl := Value;
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.FreeNotification(Self);
  end;
end;

destructor TContainer.Destroy;
begin
  { set to nil by SetSomeSpecialControl, to detach free notification }
  SomeSpecialControl := nil;
  inherited;
end;
----

## Various stuff

### Input/output using streams

Modern programs should use `TStream` class and it's many descendants to do input / output.

[source,pascal]
----
var
  S: TStream;
  A: Integer;
begin
  S := TFileStream.Create('my_binary_file.data');
  try
    S.ReadBuffer(A, SizeOf(A));
    Writeln('Got integer ', A);
  finally FreeAndNil(S) end;
end;
----

It has many useful descendants, like `TFileStream`, `TMemoryStream`, `TStringStream`.

For Castle Game Engine: You should use the `Download` method to create a stream that operates of resources (which includes files, data downloaded from URLs and Android assets). Moreover, to open the resource inside your game data (typically in `data` subdirectory) use the `ApplicationData` function.

[source,pascal]
----
EnableNetwork := true;
S := Download('http://castle-engine.sourceforge.net');
----

[source,pascal]
----
S := Download('file:///home/michalis/my_binary_file.data');
----

[source,pascal]
----

S := Download(ApplicationData('gui/my_image.png'));
----

To read text files, I advice using `TTextReader` class from `CastleClassUtils`. It provides a line-oriented API, and wraps a `TStream` inside. The `TTextReader` constructor can take a ready URL, or you can pass there your custom `TStream` source.

[source,pascal]
----
Text := TTextReader.Create(ApplicationData('my_data.txt'));
while not Text.Eof do
  WritelnLog('NextLine', Text.ReadLine);
----

### Lists

For dynamic-length lists of stuff, we advice using generic classes from the `FGL` or `CastleGenericLists` units. Use `TFPGList` for lists of primitives, `TFPGObjectList` for a list of class instances. Use `CastleGenericLists` and `TGenericStructList` for a list of records or _old-style objects_.

Using these lists is a good idea, as you get type-safety, and their API is rich (there are methods to find, sort, iterate and so on). We discourage using _dynamic arrays_ (`array of X`, `SetLength(X, ...)`) as their API is poor (you can only use `SetLength` and your own type helpers). We discourage using `TList` or `TObjectList` as it will require casting your references from `TObject` to your type.

### Old-style objects

In the old days, Turbo Pascal introduced another syntax for class-like functionality, using the `object` keyword. It's discouraged to use it anymore, except when you want to get the _record with methods_ feature. Then the old-style objects are useful.

Both `record` and `object` do not have to be allocated / freed. A simple `record` or `object` is not a reference (pointer) to something, it's simply the data. This makes them comfortable for small data, where calling allocation / free would be bothersome. It also makes them fast -- a list of such structures is nicely linear in memory, iterating over it doesn't involve jumping over pointers. Also, their memory layout is defined in _some_ situations (packed records, or records with C layout), which makes them suitable to pass to external APIs, like OpenGL.

### Overloading

Methods (and global functions and procedures) with the same name are allowed, as long as they have different parameters. At compile time, the compiler detects which one you want to use, knowing the parameters you pass.

By default, the overloading uses the FPC approach, which means that all the methods in given namespace (a class or a unit) are equal, and hide the other methods in namespaces with less priority. For example, if you define a class with methods `Foo(Integer)` and `Foo(string)`, and it descends from a class with method `Foo(Float)`, then the users of your new class will not be able to access the method `Foo(Float)` easily (they still can --- if they typecast the class to it's ancestor type). To overcome this, use the `overload` keyword.

### Preprocessor

You can use simple preprocessor directives for

* conditional compilation,
* to include one file in another,
* you can also use parameter-less macros.

Note that macros with parameters are not allowed. In general, you should avoid using the preprocessor stuff... unless it's really justified. The preprocessing happens before parsing, which means that you can "break" the normal syntax of the Pascal language. This is a powerful, but also somewhat dirty, feature.

[source,pascal]
----
{$mode objfpc}{$H+}
unit PreprocessorStuff;
interface

{$ifdef FPC}
{ This is only defined when compiled by FPC, not other compilers (like Delphi). }
procedure Foo;
{$endif}

{ Define a NewLine constant. Here you can see how the normal syntax of Pascal
  is "broken" by preprocessor directives. When you compile on Unix
  (includes Linux, Android, Mac OS X), the compiler sees this:

    const NewLine = #10;

  When you compile on Windows, the compiler sees this:

    const NewLine = #13#10;

  On other operating systems, the code will fail to compile,
  because a compiler sees this:

    const NewLine = ;

  It's a *good* thing that the compilation fails in this case -- if you
  will have to port the program to an OS that is not Unix, not Windows,
  you will be reminded by a compiler to choose the newline convention
  on that system. }

const
  NewLine =
    {$ifdef UNIX} #10 {$endif}
    {$ifdef MSWINDOWS} #13#10 {$endif} ;

{$define MY_SYMBOL}

{$ifdef MY_SYMBOL}
procedure Bar;
{$endif}

{$define CallingConventionMacro := unknown}
{$ifdef UNIX}
  {$define CallingConventionMacro := cdecl}
{$endif}
{$ifdef MSWINDOWS}
  {$define CallingConventionMacro := stdcall}
{$endif}
procedure RealProcedureName; CallingConventionMacro; external 'some_external_library';

implementation

{$include some_file.inc}
// $I is just a shortcut for $include
{$I some_other_file.inc}

end.
----

Include files have commonly the `.inc` extension, and are used for two purposes:

* The include file may only contain other compiler directives, that "configure" your source code. For example you could create a file `myconfig.inc` with these contents:
+
[source,pascal]
----
{$mode objfpc}
{$H+}
{$ifndef VER3}
  {$error This code can only be compiled using FPC version at least 3.x.}
{$endif}
----
+
Now you can include this file using `{$I myconfig.inc}` in all your sources.

* The other common use is to split a large unit into many files, while still keeping it a single unit as far as the language rules are concerned. Do not overuse this technique -- your first instinct should be to split a single unit into multiple units, not to split a single unit into multiple include files. Never the less, this is a useful technique.
  . It allows to avoid "exploding" the number of units, while still keeping your source code files short. For example, it may be better to have a single unit with _"commonly used UI controls"_ than to create _one unit for each UI control class_, as the latter approach would make the typical "uses" clause long (since a typical UI code will depend on a couple of UI classes). But placing all these UI classes in a single `myunit.pas` file would make it a long file, unhandy to navigate, so splitting it into multiple include files may make sense.
//For example, *Castle Game Engine* has a unit `CastleControls` with a couple of user-interface controls, like `TCastleButton`, `TCastleLabel`, `TCastleImageControl` and more. We could split it into many units, even to _one unit per class_, as the classes are not really tightly connected. But that would often force you to have a long `uses` clause, since a lot of user-interface code will want to use a couple of control classes. So we made a practical decision to just put all _often used controls_ in a single unit.
  . It allows to have a cross-platform unit interface with platform-dependent implementation easily. Basically you can do
+
[source,pascal]
----
{$ifdef UNIX} {$I my_unix_implementation.inc} {$endif}
{$ifdef MSWINDOWS} {$I my_windows_implementation.inc} {$endif}
----
+
Sometimes this is better than writing a long code with many `{$ifdef UNIX}`, `{$ifdef MSWINDOWS}` intermixed with normal code (variable declarations, routine implementation). The code is more readable this way. You can even use this technique more aggressively, by using the `-Fi` command-line option of FPC to include some subdirectories only for specific platforms. Then you can have many version of include file `{$I my platform_specific_implementation.inc}` and you simply include them, letting the compiler find the correct version.

## Advanced classes features

### private and strict private

The `private` visibility specifier means that the field (or method) in not accessible outside of this class. But it allows an exception: all the code defined _in the same unit_ can break this, and access private fields and methods. A C++ programmer would say that in Pascal _all classes within a single unit are friends_. This is often useful, and doesn't break your encapsulation, since it's limited to a unit.

However, if you create larger units, with many classes (that are not tightly integrated with each other), it's safer to use `strict private`. As you can guess, it means that the field (or method) in not accessible outside of this class -- period. No exceptions.

In a similar manner, there's `protected` visibility (visible to descendants, or friends in the same unit) and `strict protected` (visible to descendants, period).

### Class methods

These are methods you can call having a class reference (`TMyClass`), not necessarily a class instance.

[source,pascal]
----
type
  TEnemy = class
    procedure Kill;
    class procedure KillAll;
  end;

var
  E: TEnemy;
begin
  E := TEnemy.Create;
  try
    E.Kill;
  finally FreeAndNil(E) end;
  TEnemy.KillAll;
end;
----

Note that they can be virtual -- it makes sense, and is sometimes very useful, when combined with <<Class references>>.

Note that a constructor always acts like a class method when called in a normal fashion (`MyInstance := TMyClass.Create(...);`). Although it's possible to also call a constructor from within the class itself, like a normal method, and then it acts like a normal method. This is a useful feature to "chain" constructors, when one constructor (e.g. overloaded to take an integer parameter) does some job, and then calls another constructor (e.g. parameter-less).

### More stuff inside classes and nested classes

You can open a section of constants (`const`) or types (`type`) within a class. This way, you can even define a class within a class. The visibility specifiers work as always, so you can the nested class can even be private (not visible to the outside world).

[source,pascal]
----
type
  TMyClass = class
  private
    type
      TInternalClass = class
        Velocity: Single;
        procedure DoSomething;
      end;
    var
    FInternalClass: TInternalClass;
  public
    const
      DefaultVelocity = 100.0;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TMyClass.Create;
begin
  inherited;
  FInternalClass := TInternalClass.Create;
  FInternalClass.Velocity := DefaultVelocity;
  FInternalClass.DoSomething;
end;

destructor TMyClass.Destroy;
begin
  FreeAndNil(FInternalClass);
  inherited;
end;

{ note that method definition is prefixed with
  "TMyClass.TInternalClass" below. }
procedure TMyClass.TInternalClass.DoSomething;
begin
end;
----

### Class references

Class reference allows you to change the class type at runtime, for example to call a class method or constructor without knowing the exact class at compile-time.

[source,pascal]
----
type
  TMyClass = class(TComponent)
  end;

  TMyClass1 = class(TMyClass)
  end;

  TMyClass2 = class(TMyClass)
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  // Obviously you can do this:

  C := TMyClass.Create(nil); FreeAndNil(C);
  C := TMyClass1.Create(nil); FreeAndNil(C);
  C := TMyClass2.Create(nil); FreeAndNil(C);

  // In addition, using class references, you can also do this:

  ClassRef := TMyClass;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass1;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass2;
  C := ClassRef.Create(nil); FreeAndNil(C);
end;
----

Class references can be combined with virtual class methods. This gives a similar effect as using classes with virtual methods -- the actual method to be executed is determined at runtime.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    class procedure DoSomething; virtual; abstract;
  end;

  TMyClass1 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClass2 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  ClassRef := TMyClass1;
  ClassRef.DoSomething;

  ClassRef := TMyClass2;
  ClassRef.DoSomething;

  { And this will cause an exception at runtime,
    since DoSomething is abstract in TMyClass. }
  ClassRef := TMyClass;
  ClassRef.DoSomething;
end;
----

// This is an example why compiler cannot detect *all* uses of an abstract
// methods at compile time, in this case --- the error can only resurface
// at runtime.
//
// Poor example actually, since compiler could prevent "ClassRef := TMyClass"
// in this case?

### Class helpers

The _method_ is just a procedure or function inside a class. From the outside of the class, you call it with a special syntax `MyInstance.MyMethod(...)`. After a while you grow accustomed to thinking that _if I want to make action Action on instance X, I write `X.Action(...)`_.

But sometimes, you need to implement something that conceptually is _an action on class TMyClass_ without modifying the _TMyClass_ source code. Sometimes it's because it's not your source code, and you don't want to change it. Sometimes it's because of the dependencies -- adding a method like `Render` to a class like `TMy3DObject` seems like a straightforward idea, but maybe the base implementation of class `TMy3DObject` should be kept independent from the rendering code? It would be better to "enhance" an existing class, to add functionality to it without changing it's source code.

Simple way to do it is then to create a global procedure that takes an instance of `TMy3DObject` as it's 1st parameter.

[source,pascal]
----
procedure Render(const O: TMy3DObject; const Color: TColor);
var
  I: Integer;
begin
  for I := 0 to O.ShapesCount - 1 do
    RenderMesh(O.Shape[I].Mesh, Color);
end;
----

This works perfectly, but the downside is that calling it looks a little ugly. While usually you call actions like `X.Action(...)`, in this case you have to call them like `Render(X, ...)`. It would be cool to be able to just write `X.Render(...)`, even when `Render` is not implemented in the same unit as `TMy3DObject`.

And this is where you use class helpers. They are just a way to implement procedures / functions that operate on given class, and that are called like methods, but are not in fact normal methods -- they were added outside of the `TMy3DObject` definition.

[source,pascal]
----
type
  TMy3DObjectHelper = class helper for TMy3DObject
    procedure Render(const Color: TColor);
  end;

procedure TMy3DObjectHelper.Render(const Color: TColor);
var
  I: Integer;
begin
  // note that we access ShapesCount, Shape without any qualifiers here
  for I := 0 to ShapesCount - 1 do
    RenderMesh(Shape[I].Mesh, Color);
end;
----

NOTE: The more general concept is _"type helper"_. Using them you can add methods even to primitive types, like integers or enums. You can also add _"record helpers_" to (you guessed it...) records. See http://lists.freepascal.org/fpc-announce/2013-February/000587.html .
//And of course to records and old-style objects (both of them can also have regular methods, they are much like classes in this regard).

### Virtual constructors, destructors

Destructor name is always `Destroy`, it is virtual (since you can call it without knowing the exact class at compile-time) and parameter-less.

Constructor name is by convention `Create`.

You can change this name, although be careful with this -- if you define `CreateMy`, always redefine also the name `Create`, otherwise the user can still access the constructor `Create` of the ancestor, bypassing your `CreateMy` constructor.

In the base `TObject` it is not virtual, and when creating descendants you're free to change the parameters. The new constructor will hide the constructor in ancestor (note: don't put here `overload`, unless you want to break it).

In the `TComponent` descendants, you should override it's `constructor Create(AOwner: TComponent);`. For streaming functionality, to create a class without knowing it's type at compile time, having virtual constructors is very useful (see "class references" below).

### An exception in constructor

What happens if an exception happens during a constructor? The line

[source,pascal]
----
X := TMyClass.Create;
----

does not execute to the end in this case, `X` cannot be assigned, so who will cleanup after a partially-constructed class?

The solution of Object Pascal is that, in case an exception occurs within a constructor, then the destructor is called. This is a reason why _your destructor must be robust_, which means it should work in any circumstances, even on half-created class instance. Usually this is easy if you release everything safely, like by `FreeAndNil`.

We also have to depend in such cases that _the memory of the class is guaranteed to be zeroed right before the constructor code is executed_. So we know that at the beginning, all class references are `nil`, all integers are `0` and so on.

So below works without any memory leaks:

[source,pascal]
----
include::code-samples/exception_in_constructor_test.lpr[]
----

## Interfaces

### Good (CORBA) interfaces

We have interfaces, much like in Java. The idea is that _an interface_ declares an API, much like a class, but it does not define the implementation. A class can implement many interfaces, but it can only have 1 ancestor class.

You can cast a class to any interface it supports, and then _call the methods through that interface_. This allows to treat in a uniform fashion the classes that don't descend from each other, but still share some common functionality. You can say that "it allows to deal with cases when simple class inheritance is not enough".

//This is much like Java, where interfaces are used whenever you think of multiple inheritance.

[source,pascal]
----
include::code-samples/interfaces_corba_test.lpr[]
----

NOTE: The default interface style
//(if we would omit the `{$interfaces corba}` directive)
is _COM_. But I advice to use _CORBA_ style interfaces, and the `{$interfaces corba}` directive, in all modern code dealing with interfaces. The _COM_ interfaces are somewhat an _embarrassment to the language_, to be honest (details in the next section).
//, and it's best to avoid them if you can.

### Ugly (COM) interfaces

If you really need to use COM interfaces, beware:

* For some reason, the designer of this language feature (Borland) decided to entangle it with *two* concepts it should never be entangled with. Namely, with
+
--
  . COM (some ancient Windows technology) and
  . with reference counting (as far as I understand, this was a consequence of being related to the COM technology, for some reason COM stuff had to be reference counted).
--

// +
// The relation to COM technology has . You just have to put some random "GUID" string at the interface declaration to make it work). But the reference counting idea is baffling. Why would you connect one language feature, _interfaces_, with something so unrelated like _reference counting_? It seems, because the COM technology required it...

* You need to declare a GUID at your COM interfaces, to make the `Supports(ObjectInstance, IMyInterface)` or `ObjectInstance is IMyInterface` work. Just use _Lazarus_ GUID generator (`Ctrl + Shift + G` shortcut in the editor).

* Your class needs to implement a magic `_AddRef`, `_Release`, `QueryInterface` methods. Or descend from something that already implements them, like `TComponent`. *In the Castle Game Engine* we give you additional useful ancestors `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` for this purpose, see https://github.com/castle-engine/castle-engine/blob/master/src/base/castleinterfaces.pas .

* You can turn off the reference-counting mechanism by simple `_AddRef`, `_Release`, `QueryInterface` implementations that basically do nothing. Actually, the standard implementation of these methods in `TComponent`, `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` already does this for you.

* You need to be careful of freeing the class, when it may be referenced by some interface variables. Because the interface is released using a virtual method (because it _may be reference-counted, even though we usually hack it to not be reference-counted..._), you cannot free the underlying object instance as long as some interface variable may point to it. See _"7.7 Reference counting"_ in the FPC manual ( http://freepascal.org/docs-html/ref/refse47.html ), http://bugs.freepascal.org/view.php?id=10374 .

Here's a previous example reworked to use COM interfaces:

[source,pascal]
----
include::code-samples/interfaces_com_test.lpr[]
----

## License of this document

Copyright Michalis Kamburelis.

You have permission to redistribute and even modify this document freely, under the

* _Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA)_
* or the _GNU Free Documentation License (GFDL) (unversioned, with no invariant sections, front-cover texts, or back-cover texts)_
* (just like Wikipedia https://en.wikipedia.org/wiki/Wikipedia:Copyrights).

The source code is in AsciiDoc on https://github.com/michaliskambi/modern-pascal-introduction . Suggestions for corrections and additions, patches and pull requests, are very welcome:) You can reach me through GitHub, or my webpage https://michalis.ii.uni.wroc.pl/~michalis/ , or email michalis.kambi@gmail.com .
