# Краткое введение в современный Object Pascal для программистов
Michalis Kamburelis
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: coderay
:docinfo1:

## Для чего это нужно?

Существует множество книг и источников о Паскале, но слишком много из них говорят о старом Паскале, без классов, модулей, дженериков (generics).
// Some of them talk about Pascal before it even had classes. Some of them show classes, as done in Delphi, but fail to mention more modern features, like generics.

Поэтому я написал это краткое введение о том , что я называю *современным Object Pascal*. Большинство программистов используют его, действительно не называя так _"современный Object Pascal"_, мы просто называем  _"наш Pascal"_.
 Но представляя язык, я считаю важным подчеркнуть, что это современный, объектно-ориентированный язык. Он был *существенно* усовершенствован по сравнению со старым (Turbo) Pascal, который когда-то давно изучали в школах. Сегодня его можно вполне сравнивать C++, Java или C#.

* Он имеет все современные особенности, которые можно ожидать — классы, модули, интерфейсы, дженерики...
* Он компилируется в быстрый машинный код,
* Он очень типобезопасен,
* Высокоуровневый, но может быть низкоуровневым если это необходимо.

Он так же имеет превосходных, портативный компиляторов с открытым кодом названным _Free Pascal Compiler_, http://freepascal.org/ . И сопровождаемая IDE (редактор, отладчик, библиотека компонентов, создатель форм), названная _Lazarus_ http://lazarus.freepascal.org/ . Я являюсь создателем _Castle Game Engine_, http://castle-engine.sourceforge.net/ , является крутым портативным двух и трёхмерным игровым движком, использующим этот язык, чтобы создавать игры для многих платформ (Windows, Linux, MacOSX, Android, iOS, web плагины).

Это введение больше направлено на программистов, которые уже имеют опыт в других языках. Мы не будем раскрывать здесь значения некоторых универсальных концепций, как _"что такое класс"_, мы только покажем как они реализуются в Pascal.

## Основы

### Программа "Hello world"

[source,pascal]
----
include::code-samples/hello_world.lpr[]
----

Это полноценная программа, которую можно _скомпилировать_ и _запустить_.

* Если используется командная строка FPC, достаточно просто создать новый файл `myprogram.lpr` и выполнить команду `fpc myprogram.lpr`
* Если используется _Lazarus_, то необходимо создать новый проект (в строке меню: _Project_ -> _New Project_ -> _Simple Program_). Сохраните его как `myprogram` и вставьте в него этот исходный код. Компиляция выполняется используя пункт _Run_ → _Compile_ в меню.
* Эта консольная программа, так что, в обоих случаях, -- скомпилированный исполняемый файл нужно запустить из терминала командной строки, чтобы увидеть результат.

Остальная часть этой статьи рассказывает о самом языке Object Pascal, поэтому не ожидайте чего-нибудь большего, чем приложений командной строки. Если хочется взглянуть на что-либо более "крутое", можно просто создать новый GUI проект в _Lazarus_ (_Project_ -> _New Project_ -> _Application_).
//Play around, drop some buttons on the form, handle their events (like `OnClick`).
Вуаля! -- рабочее кроссплатформенное GUI приложение, с нативным видом, использующее удобные визуальные библиотеки. _Lazarus_ и _Free Pascal Compiler_ имеют множество готовых компонент для сетей, GUI, баз данных, чтения и записи различных форматов файлов (XML, json, изображения...), управления потоками и всем, что только может понадобиться программисту. Ярким тому примером является крутой _Castle Game Engine_, о котором упоминалось ранее:)
// The libraries created in other languages (dll, so, dylib) can be easily used from FPC too (and for most of them, you'll find ready "header" units, and even units that wrap them in more modern object-oriented API).

### Функции, процедуры, простейшие типы

[source,pascal]
----
include::code-samples/functions_primitives.lpr[]
----

Чтобы вернуть значение функции, присвой что-нибудь магическое переменной `Result`. Можно свободно читать и устанавливать переменную `Result`, так же просто как локальную переменную.

[source,pascal]
----
function MyFunction(const S: string): string;
begin
  Result := S + 'что-нибудь';
  Result := Result + ' ещё что-нибудь!';
  Result := Result + ' И ещё немножко!';
end;
----

Можно рассматривать имя функции (как `MyFunction` в примере выше) как переменную, которой можно присвоить значение и использовать как обычную переменную. Но я бы препятствовал этому в новом коде, так как это выгладит "тусклым/подозрительным" когда использовано на правой стороне присваиваемого выражение. Просто используй `Result` всегда, когда нужно использовать или устанавливать значение функции.

Если необходимо вызвать функцию рекурсивно, ты кончено можешь сделать это, но не забудь указать специальные параметры (такой рекурсивный вызов с параметром получает другой результат в отличии от резульата доступа к текущему результату функции). Так:
[source,pascal]
----
function ReadIntegersUntilZero: string;
var
  I: Integer;
begin
  Readln(I);
  Result := IntToStr(I);
  if I <> 0 then
    Result := Result + ' ' + ReadIntegersUntilZero();
end;
----

Можно вызвать `Exit`, чтобы окончить выполнение процедуры или функции до того, как она достигнет завершающего `end;`. Если вызвать без параметров `Exit` в функции, она вернёт последнее значение, присвоеное `Result`. Так же можно использовать конструкцию `Exit(X)`, чтобы установить результат функции и выйти *сейчас* — это тоже что и `return X` конструкция в С-подобных языках.

[source,pascal]
----
function AddName(const ExistingNames, NewName: string): string;
begin
  if ExistingNames = '' then
    Exit(NewName);
  Result := ExistingNames + ', ' + NewName;
end;
----

### Условные операторы (if)

Конструкции `if .. then` или `if .. then .. else` запускают некий код, когда некое условие удовлетворительно. В отличии от C-подобных языков, в Pascal нет необходимости ставить условие в скобки.

[source,pascal]
----
var
  A: Integer;
  B: boolean;
begin
  if A > 0 then
    DoSomething;

  if A > 0 then
  begin
    DoSomething;
    AndDoSomethingMore;
  end;

  if A > 10 then
    DoSomething
  else
    DoSomethingElse;

  // идентично предыдущему примеру
  B := A > 10;
  if B then
    DoSomething
  else
    DoSomethingElse;
end;
----

Оператор `else` относится к последнему условию `if`. Поэтому оно работает, как и ожидается:

[source,pascal]
----
if A <> 0 then
  if B <> 0 then
    AIsNonzeroAndBToo
  else
    AIsNonzeroButBIsZero;
----

Обертывание вложения `if` внутри `begin ... end` часто лучше, чем предыдущий пример. Оно более очевидно читателю, даже если ты перемешаешь, испортишь отступы. И когда ты добавляешь / удаляешь некий `else` пункт в коде ниже, оно очевидно к какому условию оно применяется (A тестируется или B тестируется), поэтому оно мене подвержено ошибкам.

[source,pascal]
----
if A <> 0 then
begin
  if B <> 0 then
    AIsNonzeroAndBToo
  else
    AIsNonzeroButBIsZero;
end;
----

### Логические операторы, операторы отношений и побитовые (поразрядные) операторы

_Логические операторы_ - это `and`, `or`, `not`, `xor`. Их значение, вероятно, очевидно (разве что, за исключением оператора `xor`, который в русской литературе обычно называется _"исключающее или"_). Они берут _булевские аргументы (boolean)_, и возвращают также значение типа _boolean_. Они так же могут работать как _побитовые операторы_, когда оба аргумента целого типа (integer, byte или другие), в этом случае они также возвращают значение идентичного целого типа.

_Операторы отношения (сравнения)_ - представлены очевидными комбинациями символов: `=`, `<>`, `>`, `<`, `\<=`, `>=`. Следует отметить, что в отличии от синтаксиса С-подобных языков, в Паскале оператор сравнения идентичности выглядит как один знак "равно" `A = B` (в отличии от С, где используется код `A == B`). Специальным _оператором присваивания_ в паскале является `:=`.

_Логический (или побитовый) оператор имеет более высокий приоритет, чем операторы отношения_. Поэтому может понадобиться использовать круглые скобки вокруг сравниваемых выражений.

Следующий пример вызовет ошибку компиляции:

[source,pascal]
----
var
  A, B: Integer;
begin
  if A = 0 and B <> 0 then ... // так делать НЕЛЬЗЯ
----

Ошибка связана с тем, что компилятор пытается в первую очередь пытается выполнить побитовый оператор `and` в середине выражения и в результате получается `(0 and B)`, которое возвращает целочисленную величину. Далее компиллятор выполняет оператор "равно" и получает булевскую величину `A = (0 and B)`. Финальная ошибка оказывается связана с попыткой сравнить булевскую величину `A = (0 and B)` с целочисленной величиной `0`.

Правильно будет делать следующим образом:

[source,pascal]
----
var
  A, B: Integer;
begin
  if (A = 0) and (B <> 0) then ...
----

Паскаль использует _"короткую оценку (short-circuit evaluation)"_ - оптимизацию, которая позволяет не рассчитывать выражение целиком, если его первая часть определяет результат. Рассмотрим пример:

[source,pascal]
----
if MyFunction(X) and MyOtherFunction(Y) then...
----

* Значение функции `MyFunction(X)` всегда рассчитывается первым.
* И если `MyFunction(X)` вернёт значение `false`, это означает, что мы уже знаем результат всего выражения (Какое бы ни было второе значение при выполнении `false and что-нибудь` мы всегда получим `false`). Таким образом `MyOtherFunction(Y)` вообще не будет выполняться.
* Идентичная ситуация и с выражением `or`. В данном случае, если мы наперёд знаем, что результат будет `true` потому что первый аргумент имеет значение `true`, второй аргумент не влияет на результат и вообще не рассчитывается.
* Это особенно полезно если нужно записать выражение типа:
+
[source,pascal]
----
if (A <> nil) and A.IsValid then...
----
+
Здесь не возникнет ошибки даже в случае если `A` имеет значение `nil` (т.е. нулевой указатель).

// * Using `and` between two boolean values is a logical `and`, and the result is boolean. In other words, the result is `true` only if both operands are `true`, otherwise it's `false`.

// * Using `and` between two integer values is a bit-wise `and`, and the result is integer. The operands are converted to have the same number of bits, and a similar rule is performed bit-by-bit, setting each bit to `0` or `1`. If you do this with potentially negative integer values, you should understand how negative numbers are encoded in memory (_"two's complement"_).

### Проверка одного выражения на множественные значения (оператор case)

Если в зависимости от разных значений переменной должны быть исполнены разные действия, тогда может оказаться полезной конструкция `case .. of .. end`.

[source,pascal]
----
case SomeValue of
  0: DoSomething;
  1: DoSomethingElse;
  2: begin
       IfItsTwoThenDoThis;
       AndAlsoDoThis;
     end;
  3..10: DoSomethingInCaseItsInThisRange;
  11, 21, 31: AndDoSomethingForTheseSpecialValues;
  else DoSomethingInCaseOfUnexpectedValue;
end;
----

Условие `else` опционально. Если текущее значение анализируемого выражения не совпадает ни с одним из описанных случаев и нет условия `else`, то программа просто пропустит всю конструкцию и будет выполняться дальше.

Программистам С-подобных языков полезно сравнить `case` с подобной конструкцией `switch` в этих языках. Стоит отметить, что `case` в Паскале защищён от случайного выполнения следующей инструкции. Нет необходимости помнить каждый раз размещать инструкцию `break` в конце каждого блока. После выполнения ветви условия программа автоматически закончит обработку конструкции `case` и продолжит выполнение дальше.

### Перечисляемый и порядковый типы, наборы и массивы постоянной длины

Перечисляемый тип в паскале очень аккуратный и комфортный. Возможно, Вы будете использовать его чаще чем перечисляемые типы в других языках:)

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
----

Общепринято, что префикс перечисляемого типа состоит из двух букв сокращения имени типа, следовательно `ak` = сокращение для _"Animal Kind"_. Это полезное соглашение, так как имена перечисляемых типов находятся в глобальном пространстве модуля. Так с помощью префикса `ak`, автоматически уменьшаются шансы на конфликт с другими идентификаторами.

ПРИМЕЧАНИЕ: Конфликты в именах не приводят к неработоспособности программы. Это вполне допустимо в различных модулях определять одинаковые идентификаторы. Но хорошей идеей будет попытка избежать столкновений в любом случае, чтобы код был прост в понимании и анализа. 

ПРИМЕЧАНИЕ: Можно избежать помещения имён перечисляемых типов в глобальное пространство с помощью директивы компиллятора `{$scopedenums on}`. Это значит, будет необходимо обращаться к ним с помощью обращения к имени типа, как `TAnimalKind.akDuck`. В таком случае необходимость в префиксе `ak` исчезает, и можно будет просто оставить названия `Duck, Cat, Dog`. Это похоже на перечисляемые списки C#. 

Факт того, что перечисляемый тип _комфортен_ т.е. не может быть просто присвоен к целому и присвоен из целого. Тем не менее, для специального использования, можно использовать `Ord(MyAnimalKind)`, чтобы насильно привести список к целому типу, или дать подходящую роль `TAnimalKind(MyInteger)` чтобы конвертировать integer к перечисляемому типу. В последнем случае, проверь является ли `MyInteger` частью диапазона `(0 to Ord(High(TAnimalKind)))`.

Перечисляемые и порядковые типы могут быть использованы как индексы массива:

[source,pascal]
----
type
  TArrayOfTenStrings = array [0..9] of string;
  TArrayOfTenStrings1Based = array [1..10] of string;

  TMyNumber = 0..9;
  TAlsoArrayOfTenStrings = array [TMyNumber] of string;

  TAnimalKind = (akDuck, akCat, akDog);
  TAnimalNames = array [TAnimalKind] of string;
----

Они так же могут быть использованы для создания наборов(внутренне битовое поле):

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
  TAnimals = set of TAnimalKind;
var
  A: TAnimals;
begin
  A := [];
  A := [akDuck, akCat];
  A := A + [akDog];
  A := A * [akCat, akDog];
  Include(A, akDuck);
  Exclude(A, akDuck);
end;
----

### Циклы (for, while, repeat, for .. in)

[source,pascal]
----
include::code-samples/loops.lpr[]
----

Примечания:

* Может казаться, что различие между `while` и `repeat` циклами лишь "косметические". Может показаться, что просто условие "с точностью до наоборот", в случае `while .. do` выполнение _продолжается_, пока условие _истино_, а в `repeat .. until` - выполнение _прекращается_, когда условие _выполняется_). В действительности есть другое важное отличие: в случае `repeat`, _условие не проверяется в начале_. Поэтому цикл `repeat` всегда выполняется как минимум один раз.

* Конструкция `for I := .. to .. do ...` похожа на C-подобный цикл `for`. Тем не менее, оно более ограничено, как вы не можете указать произвольное действие/тесты чтобы контролировать итерации цикла. В Паскале for используется строго для итерации через последовательные числа (или другие порядковые типы). Единственной уступкой является использование `downto` вместо `to`, чтобы производить счёт в обратном порядке.
+
С другой стороны, это существенно легче для понимания, и лучше для оптимизации в исполнении. Например, _значения верхней и нижней границы вычисляется один раз_, до начала исполнения цикла.
+
Следует также обратить внимание, что переменная, которая использовалась для цикла (в примере выше - `I`) становится неопределённой после окончания цикла кроме случая досрочного выхода из цикла с помощью команд `Break` или `Exit`.
*Цикл for `I in .. do ..` такой же как конструкция foreach в многих современных языках. Он хорошо понимает организацию всех встроенных типов:
** Он может перебирать все значения массива (см. пример выше).
** Он может перебирать все возможные значения перечисляемого типа:
+
[source,pascal]
----
var
  AK: TAnimalKind;
begin
  for AnimalKind in TAnimalKind do...
----

** Он может перебирать все элементы набора:
+
[source,pascal]
----
var
  Animals: TAnimals;
  AK: AnimalKind;
begin
  Animals := [akDog, akCat];
  for AK in Animals do ...
----

** И так же работает на всех пользовательких/кастомных типах, включая дженерики, например, `TObjectList` или `TFPGObjectList`.
+
[source,pascal]
----
include::code-samples/for_in_list.lpr[]
----
+
Мы еще не рассматривали концепцию классов, поэтому последний пример может показаться неочевидным, но мы обязательно рассмотрим этот вопрос чуть позже :)

### Вывод информации и логов

Чтобы просто вывести строки в Паскале используй процедуру `Write` или `Writeln`. Во втором случае в конце автоматически добавляется перенос строки.

Это "волшебная" процедура в Паскале, Она принимает переменное число аргументов, которые могут иметь любой тип. Они все будут приведены к строке при выводе, также можно добавить специальный синтаксис для указания как отформатировать число.

[source,pascal]
----
Writeln('Hello world!');
Writeln('Можно вывести целое число: ', 3 * 4);
Writeln('Отформатировать его: ', 666:10);
Writeln('А также вывести число с плавающей запятой: ', Pi:1:4);
----
Чтобы явно завершить строку можно использовать константу `LineEnding` constant (из FPC RTL). (_Castle Game Engine_ имеет также более краткий вариант `NL`). В отличии от HTML и других подобных разметок в паскалевских строках обратная косая (`\`) не позволяет вставлять специальные символы. По этому:

[source,pascal]
----
Writeln('Первая строка.\nВторая стока.'); // НЕВЕРНЫЙ пример
----

не будет работать так, как можно было бы предположить. Правильно делать следующим образом:

[source,pascal]
----
Writeln('Первая строка.' + LineEnding + 'Вторая строка.');
----

или так:

[source,pascal]
----
Writeln('Первая строка.');
Writeln('Вторая строка.');
----

Стоит отметить, что это будет работать только в _консольных_ приложениях. Для этого нужно указывать `{$apptype CONSOLE}` (*но не* `{$apptype GUI}`) в главном файле программы. На некоторых ОС консоль явно или скрыто присутствует всегда (Unix) и этот параметр не используется, но в некоторых системах попытка выполнения `write`/`writeln` из GUI приложения может привести к ошибке (например, в Windows).

В *Castle Game Engine:* категорически не советуется пользоваться `Writeln`, для этого есть специальная функция `WritelnLog` или `WritelnWarning` для вывода логов и отладочной информации, при этом. Их результат всегда будет направлен в полезном направлении: для Unix это будет стандартный вывод в консоль. Для Windows GUI приложений это будет лог-файл. В Android будет отображаться _Android logging facility_ (инструмент логов Андроида) (который можно просматривать с помощью команды `adb logcat`). Использовать `Writeln` есть смысл лишь в ограниченном наборе случаев, например, для консольных приложений (исполняемых из командной строки) и можно быть точно уверенным, что _стандартный вывод_ определён. Например, так можно делать в конвертере или генераторе трёхмерных моделей, который выполняется из командной строки.

### Преобразование данных в строчный тип

To convert an arbitrary number of arguments to a string (instead of just directly outputting them), you have a couple of options.

* You can convert particular types to strings using specialized functions like `IntToStr` and `FloatToStr`. Furthermore, you can concatenate strings in Pascal simply by adding them. So you can create a string like this: `'My int number is ' + IntToStr(MyInt) + ', and the value of Pi is ' + FloatToStr(Pi)`.
** _Advantage_: Absolutely flexible. There are many `XxxToStr` overloaded versions and friends (like `FormatFloat`), covering many types.
// They give you a lot of flexibility in formatting.
** _Another advantage_: Consistent with the reverse functions. To convert a string (for example, user input) back to an integer or float, you use `StrToInt`, `StrToFloat` and friends (like `StrToIntDef`).
** _Disadvantage_: A long concatenation of many `XxxToStr` calls and strings doesn't look nice.
//For classes, they can override the `TObject.ToString` method.
//It doesn't have that clean _separation of pattern and arguments_ property of `Format` call.

* The `Format` function, used like `Format('%d %f %s', [MyInt, MyFloat, MyString])`. This is like `sprintf` function in the C-like languages. It inserts the arguments into the placeholders in the pattern. The placeholders may use special syntax to influence formatting, e.g. `%.4f` results in a floating-point format with 4 digits after the decimal point.
** _Advantage_: The separation of _pattern_ string from _arguments_ looks clean. If you need to change the pattern string without touching the arguments (e.g. when translating), you can do it easily.
** _Another advantage_: No compiler magic. You can use the same syntax to pass any number of arguments of an arbitrary type in your own routines (declare parameter as an `array of const`). You can then pass these arguments downward to `Format`, or deconstruct the list of parameters and do anything you like with them.
** _Disadvantage_: Compiler does not check whether the pattern matches the arguments. Using a wrong placeholder type will result in an exception at runtime (`EConvertError` exception, not anything nasty like a segmentation fault).
//Note that, unlike the C `sprintf`, the correctness at runtime can be completely verified (there are no dirty pointer tricks inside

* `WriteStr(TargetString, ...)` routine behaves much like `Write(...)`, except that the result is saved to the `TargetString`.
** _Advantage_: It supports all the features of `Write`, including the special syntax for formatting like `Pi:1:4`.
** _Disadvantage_: The special syntax for formatting is a "compiler magic", implemented specifically for routines like this. This is sometimes troublesome, e.g. you cannot create your own routine `MyStringFormatter(...)` that would also allow the special syntax like `Pi:1:4`. For this reason (and also because it wasn't implemented for a long time in major Pascal compilers), this construction is not very popular.

## Модули (Units)

Модули позволяют группировать общие функции и объекты (всё, что может быть объявлено), для использования другими модулями и программами. Они эквивалентны _модулям_ и _пакетам_ в других языках. Они имеют секцию интерфейса, где объявляются доступные для других модулей и программ переменные, функции и т.п., секцию их реализации, где описано, как они работают. Модуль `MyUnit` можно сохранить под именем `myunit.pas` (название должно быть без заглавных букв с расширением `.pas`).

[source,pascal]
----
include::code-samples/myunit.pas[]
----

Финальная программа сохраняются в виде файлов типа `myprogram.lpr` (`lpr` = Lazarus program file; в Delphi используются `.dpr`). Следует отметить, что возможны и другие расширения, например, некоторые проекты просто используют `.pas` в качестве основного файла программы, изредка для модулей используются расширения `.pp`. Лично я предпочитаю использовать `.pas` для модулей и `.lpr` для FPC/Lazarus программ.

Программа может подключать модуль с помощью ключевого слова `uses`:

[source,pascal]
----
include::code-samples/myunit_test.lpr[]
----

### Перекрёстные ссылки между модулями

Не только основная программа, но и модули также могут ссылаться на другие модули. Другой модуль может войти в секцию interface или только в implementation. Первый вариант позволяет создавать новые определения (процедуры, типы...), используя или наследуя информацию из другого модуля. Во втором варианте возможности более ограничены, если использовать модуль в секции implementation, то применить его идентификаторы возможно лишь в рамках implementation данного модуля.

[source,pascal]
----
include::code-samples/anotherunit.pas[]
----

Запрещено применять _кольцевую взаимозависимость_ в разделе interface.  Т.е. два модуля не могут использовать друг друга в разделе interface.
//that everything must be declared before it's used.
Причина такого ограничения заключается в том, чтобы "понять"
//(e.g. determine the memory layout of all the structures)
секцию interface модуля, компилятор анализирует и "понимает" все модули, перечисленные в uses в секции interface.
Pascal language follows this rule strictly, and it allows a fast compilation and fully automatic detection on the compiler side _what units need to be recompiled_. There is no need to use complicated ``Makefile`` files for a simple task of compilation in Pascal, and there is no need to _recompile everything_ just to make sure that all dependencies are updated correctly.
//, but also makes circular dependencies _between units interfaces_ impossible.
//(That said, this constraint is not existing in some other languages. You can actually do parsing without "complete understanding" of your dependencies, just some stuff will have to be resolved later, e.g. at linking. You can also "repeat" the compilation until your knowledge is "settled". Anyway, you have to live with this constraint now, and enjoy fast compilation times.:)

Вполне возможно создавать кольцевые зависимости между модулями когда один из них "используется" только в implementation. Поэтому нормально для `A` использовать `B` в interface, и затем модуль `B` использует `A` в implementation.

### Определение идентификаторов с именем модуля

Различные модули могут определять одинаковые идентификаторы. Чтобы поддерживать код простым для чтения и поиска, обычно следует избегать таких совпадений, но это не всегда возможно. В таких случаях, последний модуль в списке `uses` "перетягивает одеяло на себя", т.е. идентификаторы определенные в нём скрывают одноимённые идетификаторы вводимые другими модулями ранее.
// in some situations (e.g. when you use a third-party library).

Возможно всегда недвусмысленно определить модуль дающего идентификатор, используя как `MyUnit.MyIdentifier`. Это обычное решение когда используемый идентификатор из `MyUnit` скрыт в другом модуле. Таким же образом можно перестроить порядок модулей в списке uses, хотя это может повлиять не только на исправляемые идентификаторы, но и на другие.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
program showcolor;

// Модули Graphics и GoogleMapsEngine определяют свой тип TColor.
uses Graphics, GoogleMapsEngine;

var
  { Это сработает не так, как ожидается, поскольку TColor
    определяется последним модулем в списке - GoogleMapsEngine. }
  // Color: TColor;
  { А так будет правильно. }
  Color: Graphics.TColor;
begin
  Color := clYellow;
  Writeln(Red(Color), ' ', Green(Color), ' ', Blue(Color));
end.
----

В случае модулей следует также опмнить, что они могут иметь два списка `uses`: один - в секции `interface`, другой - в `implementation`. Правило - _Позднейшие модули скрывают все что было делают предыдущие модули_ и применяется последовательно, что означает, что _модули использованые в секции implementation_ могут скрывать идентификаторы из _модулей использованных в секции interface_. Тем не менее не стоит забывать, что в процессе чтения секции interface компилятором, только модули использованные в секции interface имеют значение. Это может сбить с толку в ситуациях, когда два на вид одинаковых объявления обрабатываются по-разному компилятором:

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

// НЕВЕРНЫЙ пример

interface

uses Graphics;

procedure ShowColor(const Color: TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: TColor);
begin
  // Writeln(ColorToString(Color));
end;

end.
----

Модуль `Graphics` (из набора библиотек Lazarus LCL) определяет тип `TColor`. Но компилятор указывает на ошибку в этом модуле, заявляя что заявленная в секции Interface процедура `ShowColor` не описана. Проблема в том, что модуль `GoogleMapsEngine` так же определяет тип `TColor`, который используется только в секции `implementation`, следовательно оно _перекрывает_ определение `TColor` только в секции implementation. Т.е. компилятор видит это буквально как:


[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

// НЕВЕРНЫЙ пример
// демонстрирующий, как предыдущий пример "видит" компилятор

interface

uses Graphics;

procedure ShowColor(const Color: Graphics.TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: GoogleMapsEngine.TColor);
begin
  // Writeln(ColorToString(Color));
end;

end.
----

Решение в данном случае - тривиальное, нужно просто изменить implementation, чтобы явно использовать `TColor` из модуля `Graphics`. Это также можно исправить, переметив подключение модуля `GoogleMapsEngine` в секцию interface до модуля `Graphics`. Впрочем, это может привести к последствиям внутри модуля `UnitUsingColors` и коснётся всех его определений.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

interface

uses Graphics;

procedure ShowColor(const Color: TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: Graphics.TColor);
begin
  // Writeln(ColorToString(Color));
end;

end.
----

### Использование идентификаторов одного модуля в другом

Иногда возникает необходимость взять идентификатор из одного модуля, и _использовать_ либо _изменять_ его в другом модуле. Результатом должно быть тем, что использование нового модуля делает идентификатор доступным в пространстве имён.

Иногда подобные манипуляции необходимы для сохранения совместимости с предыдущими версиями версиями модуля. Иногда неплохо "скрыть" внутренний unit в данной ситуации.

Это может быть осуществлено с помощью переопределения идетификатора в новом модуле.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit MyUnit;

interface

uses Graphics;

type
  { Использовать TColor из модуля Graphics для определения TMyColor. }
  TMyColor = TColor;

  { Как вариант, можно переопределить его под тем же именем.
    В таком варианте необходимо будет указать нименование модуля, иначе
    получится несогласованное определение "TColor = TColor". }
  TColor = Graphics.TColor;

const
  { С константами это тоже работает. }
  clYellow = Graphics.clYellow;
  clBlue = Graphics.clBlue;

implementation

end.
----

Стоит отметить, что данный трюк не пройдёт с глобальными процедурами, функциями и переменными. С ними необходимо объявить постоянный указатель на процедуру в другом модуле (см. <<Callbacks>>), но такой код выглядит не совсем чисто.

Обычным решением является создание тривиальной "функции-обертки", которая под видом простого вызова функции из внешнего модуля, просто передаёт ему параметры и возвращает принимаемые значения обратно.

Чтобы проделать тоже с глобальными параметрами иногда используются глобальные (unit-level) свойства, см. <<Properties>>.

## Классы (Classes)

### Основы

В Pascal для объектно-ориентированного программирования чаще всего используются классы (classes). На базовом уровне класс просто является контейнером для

* _поля (field)_ (удобное имя для _"переменной внутри класса"_),
* _методы (method)_ (удобное имя для _"a процедуры или функции внутри класса"_),
* и _свойства (property)_ (удобный синтаксис для конструкции подобной полю, однако в действительности являющейся парой методов, используемых для _чтения (get)_ и _записи (set)_ чего-либо; детальнее см. <<Properties>>).
* Вообще говоря в классах можно разместить <<More stuff inside classes and nested classes>>, но об этом пойдёт речь чуть позже.

[source,pascal]
----
type
  TMyClass = class
    MyInt: Integer;
    procedure MyMethod;
  end;

procedure TMyClass.MyMethod;
begin
  Writeln(MyInt + 10);
end;
----

### Наследование (Inheritance), проверка (is), и приведение типов (as)

Паскаль поддерживает наследование и виртуальные методы ООП.

[source,pascal]
----
include::code-samples/inheritance.lpr[]
----

По умолчанию методы являются виртуальными, чтобы сделать их такими, необходимо использовать специальное ключевое слово `virtual`. Перекрытие или замещение виртуального метода осуществляется с помощью ключевого слова `override`, в ином случае будет ошибка. Чтобы скрыть метод без перекрытия следует использовать ключевое слово `reintroduce`, однако обычно не стоит так делать кроме случаев, когда для этого есть особые причины.

Чтобы узнать, является ли класс из семейства классов конкретным его экземпляром можно использовать оператор `is`. Для выполнения приведения типа класса к конкретному экземпляру следует использовать оператор `as`.

[source,pascal]
----
include::code-samples/is_as.lpr[]
----

Вместо приведения типа `X as TMyClass`, можно также использовать приведение типа _без проверки_ с помощью выражения типа `TMyClass(X)`. Такой код будет работать чуть-чуть быстрее, но может привести к неопределённому поведению в случае если  `X` не является наследником `TMyClass`. По этому конструкцию `TMyClass(X)` лучше не использовать в программе кроме случаев, когда абсолютно очевидно, что здесь не может быть ошибок, например, если тип класса был проверен с помощью оператора `is`:

[source,pascal]
----
if A is TMyClass then
  (A as TMyClass).CallSomeMethodOfMyClass;
// вариант ниже - работает незначительно быстрее
if A is TMyClass then
  TMyClass(A).CallSomeMethodOfMyClass;
----
### Свойства (Properties)

Свойства (Properties) являются _"синтаксическим сахаром" (syntax sugar - жаргон, означающий синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для программиста)_ который можно использовать с целью:

1. Сделать что-то внешнее похожее на поле (может быть прочитано и установлено) но ниже реализовано вызовом функциями _считывания значения (getter)_ и _установки значения (setter)_. Самое обычное применение такого подхода - выполннение дополнительных действий каждый раз, когда некоторое значение изменяется.
2. Сделать что-то внешне похожее на поле, но только доступное для чтения. В результате, это что-то вроде константы или функции без параметров.

[source,pascal]
----
type
  TWebPage = class
  private
    FURL: string;
    FColor: TColor;
    function SetColor(const Value: TColor);
  public
    { Невозможно напрямую установить.
      Следует вызвать метод вроде Load('http://www.freepascal.org/'),
      для загрузки страницы и установки значения этого свойства. }
    property URL: string read FURL;
    procedure Load(const AnURL: string);
    property Color: TColor read FColor write SetColor;
  end;

procedure TWebPage.Load(const AnURL: string);
begin
  FURL := AnURL;
  NetworkingComponent.LoadWebPage(AnURL);
end;

function TWebPage.SetColor(const Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    // Например, требовать обновления, каждый раз когда это значение изменяется
    Repaint;
    // Ещё пример: обеспечить чтобы нечто изменялось синхронно
    // с установкой цвета, например
    RenderingComponent.Color := Value;
  end;
end;
----

// { compare with the old value, to shield from making
//   useless assignments to RenderingComponent.Color.
//   This is a common approach to guarantee that setting WebPage.Color
//   many times to the same value will be fast,
//   even if setting RenderingComponent.Color many times to the same value
//   would be slow. }

Note that instead of specifying a method, you can also specify a field (typically a private field) to directly get or set. In the example above, the `Color` property uses a _setter_ method `SetColor`. But for getting the value, the `Color` property refers directly to the private field `FColor`. Directly referring to a field is faster than implementing trivial getter or setter methods (faster for you, and faster at execution).

При объявлении свойства указывается:

. может ли оно быть прочитано, и как (с помощью прямого чтения поля, или с использованием метода `getter`).
. может ли оно быть установлено, и как (с помощью прямой записи поля, или вызовом метода `setter`).

Компилятор следит за тем, чтобы типы и параметры соответствующих полей и методов совпадали с типом свойства с которым они работают. Например, чтобы прочитать свойство `Integer` следует или предоставить поле `Integer`, или беспараметрический метод (функцию), который возвращает `Integer`.

С технической точки зрения, для компилятора, методы "getter" и "setter"  - обычные методы и они могут делать абсолютно что угодно (включая массу дополнительных функций). Но правилом хорошего тона является создавать такие свойства, которые ведут себя более-менее подобно обычному полю:

// There are some good conventions to follow when creating properties. These are only conventions, the compiler doesn't prevent you from making something weird using properties -- f. But the good
// They should be somewhat predictable, like fields:

* Функция _getter_ не должна иметь видимые побочные эффекты (например, она не должна читать некоторый ввод из файла / клавиатуры). Её значение должно быть детерменистическим (без рандомизации или псевдо-рандомизации :)) Чтение свойства каждый раз должно иметь смысл и возвращать одинаковый результат, если между операциями чтения ничего не изменилось.
+
Следует отметить, что вполне нормально если выполнение _getter_ имеет некие _невидимые_ последствия, например, сохранение в кеше результатов некоторого вычисления для ускорения выполнения кода при следующем вызове. По факту, это одна из очень полезных возможностей функции "getter".

* Функция _setter_ должна всегда устанавливать значение таким образом, чтобы _getter_ вернул его же обратно. Не стоит автоматически отбрасывать неверные значения "setter", если это необходимо, стоит вызвать exception. Также не следует конвертировать или масштабировать запрашиваемое значение. Главная идея заключается в том, чтобы после установки `MyClass.MyProperty := 123;` программист ожидал, что `MyClass.MyProperty = 123`.

* _read-only свойства_ часто используют для создания неких полей доступных только для чтения снаружи. Снова таки, хорошеая практика - делать их поведение похожим на константу, по крайней мере для данного экземпляра объекта в его текущем состоянии. Значение свойства не должно меняться неожиданно. _Если необходимо возвращать что-то случайное, лучше сделать функцию, а не свойство._

* Поле, к которому обращаются свойства почти всегда находится в разделе _private_, поскольку главная идея свойств - служить обёрткой и методом доступа к нему.

* Технически, возможно создать свойства, которые только устанавливают значение, но не читают его. Впрочем, хороших примеров такой реализации мне ещё не встречалось :)

ПРИМЕЧАНИЕ: Свойства так же могут быть определены вне класса, на уровне модуля. Они служат аналогичной цели: они внешне выглядят как глобальные переменные, но доступ к ним вызывает соответствующие функции _getter_ и _setter_.

### Исключения

В паскале можно вызывать и использовать исключения. Их можно "ловить" с помощью конструкции `try ... except ... end`, также можно применять секцию "выполнить в конце" `try ... finally ... end`.

[source,pascal]
----
include::code-samples/exception_finally.lpr[]
----

Обратите внимание, что раздел `finally` будет выполнен даже в случае, если выполнение будет прекращено командой `Exit` (из функции, процедуры или метода), операторами `Break` или `Continue` (внутри тела цикла).

### Разделы видимости

Как и в большинстве объектно-ориентированных языках, в паскале имеются визуальные спецификаторы для ограничения "видимости" полей / методов / свойств.

Основные уровни видимости являются следующими:

`public`:: каждый имеет доступ, включая код в других модулях.
`private`:: доступен только только в этом классе.
`protected`:: доступен только в этом классе и его наследниках.

Краткое описание `private` и `protected`, данное выше, не полностью верно. Код в _текущем модуле_ может преодолевать эти границы, и получить доступ к `private` и `protected`. Иногда это полезная особенность, позволяющая реализовывать плотно связанные классы. В остальных же случаях следует использовать `strict private` или `strict protected` для организации полной недоступности данных методов, полей или свойств. Детальнее этот вопрос рассматривается в разделе <<private and strict private>>.

По умолчанию если видимость не указана, то видимость соответствует `public`. исключение составляют классы, которые объявляются при включённой директиве `{$M+}`, либо наследники классов, которые были скомпиллированы при `{$M+}`, что включает в себя всех потомков `TPersistent`, а также потомков `TComponent` (поскольку `TComponent` является потомком `TPersistent`). Для таких классов по умолчанию видимость принимается `published`, которая подобна `public`, однако позволяет работать с ними с помощью потоковой (stream) системы.

Однако, не каждой области или свойству типа позволено быть в секции published (не каждый тип может быть конвертирован в поток (stream), и лишь классы могут быть в потоке из простых полей). Если нет необходимости создавать потоки, но нужно просто что-то доступное для всех пользователей, то следует использовать `public`.

### Предок по умолчанию

Если не объявить класс-предок по умолчанию, каждый `class` наследует `TObject`.

## Освобождение памяти классов

### Всегда необходимо освобождать экземпляры класса
Чтобы избежать утечек памяти, все экзэмпляры класса должны быть освобождены вручную. Хорошей практикой является использование опции компиллятора FPC -gl -gh, чтобы обнаруживать утечки памяти (детальнее см. http://castle-engine.sourceforge.net/tutorial_optimization.php#section_memory ).

Следует обратить внимание, что это не касается поднятых исключений (raised exceptions). Не смотря на то, что при поднятии исключения действительно создаётся класс (и это вполне обычный класс, для этих целей также можно создавать свои классы), этот экземпляр класса освобождается автоматически.

### Каким образом освобождать память

Самым лучшим методом освобождения класса является операция `FreeAndNil(A)` вызванная для данного экземпляра класса. Она проверяет, не имеет ли `A` значение `nil`, и если нет -- вызывает его деструктор (destructor), и устанавливает значение `A` в `nil`. Таким образом повторный вызов такой процедуры не приведёт к ошибке.

Приблизительно это соответствует следующему:

[source,pascal]
----
if A <> nil then
begin
  A.Destroy;
  A := nil;
end;
----

Впрочем, это слишком упрощено, поскольку `FreeAndNil` совершает ещё одно полезное действие, сразу устанавливая `A` значение `nil` *до того* как будет вызван destructor данного класса. Это позволяет избежать целой группы багов благодаря тому, что "внешний" код не сможет получить доступ к не до конца уничтоженному экземпляру класса.

Иногда можно заметить, что применяется метод `A.Free` который соответствует следующему коду:

[source,pascal]
----
if A <> nil then
  A.Destroy;
----

Т.е. освобождает класс `A`, если он не равен `nil`.

Стоит отметить, что в нормальных условиях никогда не стоит вызывать метод класса, который может оказаться `nil`. По этому `A.Free` может выглядеть подозрительно на первый взгляд, поскольку `A` может иметь значение `nil`. Однако, метод `Free` является исключением из этого правила. Это выглядит немного "грязновато" -- а именно, выполняется проверка `Self <> nil`. Такой фокус работает только для не-виртуальных методов (т.е. в случае, если не вызываются виртуальные методы и не требуется доступ к полям класса).

По этому лучше всегда использовать `FreeAndNil(A)`, без исключений, и никогда не использовать метод `Free` или деструктор `Destroy`. Такой концепции придерживается _Castle Game Engine_. Это позволяет быть уверенным, что все ссылки _либо равны `nil`, либо указывают на существующий рабочий экземпляр класса_.

### Ручное и автоматическое освобождение памяти

Во многих ситуациях, необходимость освобождать instance не является чем-то сложным. Просто пишется destructor, как пара соответствующему constructor-у, и освобождает все объекты, память для которых была выделена в constructor-е (а, точнее, в продолжение всего времени существования класса). Следует следить за тем, чтобы освобождать каждый объект лишь *один раз*. Хорошей практикой будет устанавливать значение освобождённой ссылки в  `nil`, а наиболее удобно сделать это, вызвав команду `FreeAndNil(A)`.

Например:

[source,pascal]
----
uses SysUtils;

type
  TGun = class
  end;

  TPlayer = class
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  Gun1 := TGun.Create;
  Gun2 := TGun.Create;
end;

destructor TPlayer.Destroy;
begin
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  inherited;
end;
----

Чтобы избежать необходимости каждый раз явно освобождать instance, можно использовать полезную особенность `TComponent`, которая называется _"ownership"_ (владение дочерним объектом). Любой объект, который _owned_ (т.е. которым данный класс владеет) будет автоматически освобождён _owner_-ом (классом, который им владеет). Механизм очень гибкий и никогда не освобождает объекты, которые уже освобождены (таким образом всё будет работать правильно и для несозданных объектов или освобождённых ранее). Таким образом предыдущий пример можно переписать так:

[source,pascal]
----
uses SysUtils, Classes;

type
  TGun = class(TComponent)
  end;

  TPlayer = class(TComponent)
    Gun1, Gun2: TGun;
    constructor Create(AOwner: TComponent); override;
  end;

constructor TPlayer.Create(AOwner: TComponent);
begin
  inherited;
  Gun1 := TGun.Create(Self);
  Gun2 := TGun.Create(Self);
end;
----

Следует обратить внимание, что также необходимо override virtual-ный constructor от `TComponent`. Это в свою очередь означает, что нельзя изменять параметры  constructor-а. Впрочем, это возможно -- объявив новый constructor с ключевым словом `reintroduce`. Однако здесь стоит быть осторожным, так как некоторый функционал, например, streaming, настроена на использование virtual constructor, по этому следует удостовериться, что в любом случае всё будет работать верно.

Ещё один механизм автоматического освобождения памяти -- функционал `OwnsObjects` (который по умолчанию `true`) классов-списков, таких, как `TFPGObjectList` или `TObjectList`. Т.е. можно написать:

[source,pascal]
----
uses SysUtils, Classes, FGL;

type
  TGun = class
  end;

  TGunList = specialize TFPGObjectList<TGun>;

  TPlayer = class
    Guns: TGunList;
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  // Вообще говоря, параметр OwnsObjects и так true по умолчанию
  Guns := TGunList.Create(true);
  Gun1 := TGun.Create(Self);
  Guns.Add(Gun1);
  Gun2 := TGun.Create(Self);
  Guns.Add(Gun2);
end;

destructor TPlayer.Destroy;
begin
  { Здесь достаточно освободить сам список.
    Он сам автоматически освободит всё содержимое. }
  FreeAndNil(Guns);

  { Таким образом нет нужды освобождать Gun1, Gun2 отдельно.
    Правда, хорошей практикой будет теперь установить их ссылку в "nil".
    поскольку мы знаем, что они освобождены. В этом простом классе с простым
    destructor-ом, очевидно, что к ним не произойдёт доступа, однако
    в случае сложных destructor-ов это может оказаться полезно.

    Альтернативно, можно избежать объявления Gun1 и Gun2 отдельно
    и использовать напрямую Guns[0] и Guns[1] в коде.
    Можно также создать метод Gun1, который ссылается на Guns[0]. }
  Gun1 := nil;
  Gun2 := nil;
  inherited;
end;
----

Заметим, что механизм "ownership" классов-списков простой и в случае высвобождения содержащейся в списке instance сторонним кодом возникнет ошибка. Чтобы исключить что-либо из списка без освобождения используется метод `Extract`, однако это также означает, что в дальнейшем элемент необходимо будет освобождать вручную.

В *Castle Game Engine*: Все descendants класса `TX3DNode` автоматически управляют памятью при добавлении как children другой `TX3DNode`. Корневая X3D node, `TX3DRootNode`, в свою очередь обычно владеется классом `TCastleSceneCore`. Другие объекты также имеют простой механизм владения -- обычно это обозначено parameter-ом или property под названием подобным `OwnsXxx`.

### Free notification

Если создать дополнительную ссылку на instance получается, что две ссылки указывают на одну и ту же область памяти. Если освободить одну из них, вторая окажется _"болтающимся" указателем_. Нельзя пытаться получить доступ к области памяти, которая была освобождена. Это может привести к runtime ошибке (чаще всего SIGSEGV), либо может быть получено неопределённое значение (в случае, если эта область памяти уже повторно выделена для других элементов внутри текущей программы).

В таком случае не достаточно просто вызывать `FreeAndNil` поскольку эта функция установит `nil` лишь для переданной её ссылки -- не существует автоматического метода. Рассмотрим следующий пример:

[source,pascal]
----
var
  Obj1, Obj2: TObject;
begin
  Obj1 := TObject.Create;
  Obj2 := Obj1;
  FreeAndNil(Obj1);

  // что произойдёт, если попытаться получить доступ к объекту Obj1 или Obj2?
end;
----

1. В конце данного блока ссылка `Obj1` является `nil`. Если необходимо получить доступ к ней в коде программы, для надёжности следует использовать проверку `if Obj1 <> nil then ...` чтобы случайно не вызвать метод уже освобождённой instance, например:
+

[source,pascal]
----
if Obj1 <> nil then
  Writeln(Obj1.ClassName);
----
+
Попытка доступа к ссылке `nil` на instance приведёт к предсказуемой и понятной ошибке. Таким образом, даже если код не будет проверять `Obj1 <> nil`, и попытается вслепую получить доступ к `Obj1`, возникнет достаточно ясное сообщение об ошибке.
+
То же самое происходит и при попытке вызова virtual method, или не-virtual method который пытается получить доступ к полю освобождённой instance.

2. Ситуация с `Obj2` -- куда сложнее. Её значение не `nil`, однако оно ошибочно. Попытка доступа к не-nil неверной ссылки на instance
//(or call a method that accessed a field of such instance)
приводит к непредсказуемому результату -- это может быть и access violation exception, а может и какое-то случайное значение.

К решению такой проблемы есть несколько путей:

* Первое решение - внимательно читать документацию к объекту. Не предполагать ничего о длительности жизни ссылки, если она создана чужим кодом. Если в классе `TCar` есть поле, указывающее на instance типа `TWheel`, то есть _правило_ что ссылка на _wheel_ верна, пока существует класс _car_, и сам _car_ освободит все его _wheel_ используя свой destructor. Но это правило, в более сложных случаях в документации следует сделать упоминание того, как и что происходит со ссылками.

* В примере выше, сразу после освобождения `Obj1` instance, можно просто вручную установить `Obj2` значение `nil`. В данном конкретном примере это просто и тривиально.

* Однако, наиболее перспективным решением использовать специальный механизм класса `TComponent` под названием "free notification" (извещение об освобождении). Этим образом один компонент может получить notification в случае освобождения одной из компонент, и далее установить ссылку на неё в `nil`.
+
Таким образом можно получить _слабую ссылку_. Использовать эту механику можно в различных задачах, например, позволить коду извне изменять ссылки, в том числе, возможность освобождать память в любой момент.
+
Для этого оба класса должны наследовать `TComponent`. Обычно это сводится к использованию `FreeNotification` , `RemoveFreeNotification`, и override `Notification`.
+
Следующий пример демонстрирует как использовать этот подход вместе с constructor / destructor и setter property. Иногда можно всё сделать намного проще, но здесь демонстрируется полномасштабная версия, которая будет верной в любом случае.
+
[source,pascal]
----
type
  TControl = class(TComponent)
  end;

  TContainer = class(TComponent)
  private
    FSomeSpecialControl: TControl;
    procedure SetSomeSpecialControl(const Value: TControl);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    destructor Destroy; override;
    property SomeSpecialControl: TControl
      read FSomeSpecialControl write SetSomeSpecialControl;
  end;

implementation

procedure TContainer.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSomeSpecialControl) then
    { установить значение nil для SetSomeSpecialControl чтобы всё аккуратно подчистить }
    SomeSpecialControl := nil;
end;

procedure TContainer.SetSomeSpecialControl(const Value: TControl);
begin
  if FSomeSpecialControl <> Value then
  begin
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.RemoveFreeNotification(Self);
    FSomeSpecialControl := Value;
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.FreeNotification(Self);
  end;
end;

destructor TContainer.Destroy;
begin
  { Установить значение nil для SetSomeSpecialControl, чтобы запустить notification про освобождение памяти }
  SomeSpecialControl := nil;
  inherited;
end;
----

## Run-time library

### Ввод/вывод с помощью потоков

Modern programs should use `TStream` class and it's many descendants to do input / output. It has many useful descendants, like `TFileStream`, `TMemoryStream`, `TStringStream`.

[source,pascal]
----
include::code-samples/file_stream.lpr[]
----

*In the Castle Game Engine*: You should use the `Download` method to create a stream that operates of resources (which includes files, data downloaded from URLs and Android assets). Moreover, to open the resource inside your game data (typically in `data` subdirectory) use the `ApplicationData` function.

[source,pascal]
----
EnableNetwork := true;
S := Download('http://castle-engine.sourceforge.net');
----

[source,pascal]
----
S := Download('file:///home/michalis/my_binary_file.data');
----

[source,pascal]
----
S := Download(ApplicationData('gui/my_image.png'));
----

To read text files, I advice using `TTextReader` class from `CastleClassUtils`. It provides a line-oriented API, and wraps a `TStream` inside. The `TTextReader` constructor can take a ready URL, or you can pass there your custom `TStream` source.

[source,pascal]
----
Text := TTextReader.Create(ApplicationData('my_data.txt'));
while not Text.Eof do
  WritelnLog('NextLine', Text.ReadLine);
----

### Lists

For dynamic-length lists of stuff, I advice using generic classes from the `FGL` unit. Use `TFPGList` for lists of primitives (or records or old-style objects), `TFPGObjectList` for a list of class instances. *In the Castle Game Engine:* You can also use `CastleGenericLists` with `TGenericStructList` for a list of records or old-style objects, this workarounds the problem of impossibility to override their operators in older FPC versions.

Using these lists is a good idea, as you get type-safety, and their API is rich (there are methods to find, sort, iterate and so on). We discourage using _dynamic arrays_ (`array of X`, `SetLength(X, ...)`) as their API is poor (you can only use `SetLength` and your own type helpers). We discourage using `TList` or `TObjectList` as it will require casting your references from `TObject` to your type.

### Cloning: TPersistent.Assign

To allow copying a class instance, the standard approach is to derive your class from `TPersistent`, and override it's `Assign` method. There is no magic copying here, you need to implement the `Assign` to actually copy the fields you want.

You should carefully implement the `Assign` method, to copy from a class that may be a descendant of the current class.

[source,pascal]
----
include::code-samples/persistent.lpr[]
----

Sometimes it's more comfortable to alternatively override the `AssignTo` method in the source class, instead of overriding the `Assign` method in the target class.

Be careful when calling `inherited` in the `Assign` implementation. You should _call inherited `TPersistent.Assign` only if you cannot handle the assignment in your code_ (this allows the `AssignTo` method to work, or otherwise raise an exception when assignment cannot be done). On the other hand, if your class descends from another class that already implements the `Assign` method, then _always call the inherited ``TMyClass.Assign``_. See the example above.

NOTE: Remember that when descending from `TPersistent`, the default _visibility specifier_ is `published`, to allow streaming of `TPersistent` descendants. Not all field and property types are allowed in the `published` section. If you get errors related to it, and you don't care about streaming, just change the visibility to `public`. See the <<Visibility specifiers>> section.

## Various language features

### Local (nested) routines

Inside a larger _routine_ (function, procedure, method) you can define a helper routine.

//It has all the flexibility of a normal routine, it's just not
//This is quite powerful feature that allows you to _easily_ split a long routine into many smaller ones.

The local routine can freely access (read and write) all the parameters of a parent, _and all the local variables of the parent that were declared above it_. This is very powerful. It often allows to split long routines into a couple of small ones without much effort (as you don't have to pass around all the necessary information in the parameters). Be careful to not overuse this feature -- if many nested functions use (and even change) the same variable of the parent, the code may get hard to follow.

These two examples are equivalent:

[source,pascal]
----
procedure SumOfSquares(const N: Integer): Integer;

  function Square(const Value: Integer): Integer;
  begin
    Result := Value * Value;
  end;

var
  I: Integer;
begin
  Result := 0;
  for I := 0 to N do
    Result := Result + Square(I);
end;
----

Another version, where we let the local routine `Square` to access `I` directly:

[source,pascal]
----
procedure SumOfSquares(const N: Integer): Integer;
var
  I: Integer;

  function Square: Integer;
  begin
    Result := I * I;
  end;

begin
  Result := 0;
  for I := 0 to N do
    Result := Result + Square;
end;
----

Local routines can go to any depth -- which means that you can define a local routine within another local routine. So you can go wild (but please don't go _too wild_, or the code will get unreadable:).

[[Callbacks]]

### Callbacks (aka events, aka pointers to functions, aka procedural variables)

They allow to call a function indirectly, through to a variable. The variable can be assigned at runtime to point to any function _with matching parameter types and return types_.

The callback can be:

* Normal, which means it can point to any normal routine (not a method, not local).
+
[source,pascal]
----
include::code-samples/callbacks.lpr[]
----

* A method: declare with `of object` at the end.
+
[source,pascal]
----
include::code-samples/callbacks_of_object.lpr[]
----
+
Note that you _cannot_ pass global procedures / functions as methods. They are incompatible. If you have to provide an `of object` callback, but don't want to create a dummy class instance, you can pass <<Class methods>> as methods.
+
[source,pascal]
----
type
  TMyMethod = function (const A, B: Integer): Integer of object;

  TMyClass = class
    class function Add(const A, B: Integer): Integer
    class function Multiply(const A, B: Integer): Integer
  end;

var
  M: TMyMethod;
begin
  M := @TMyClass(nil).Add;
  M := @TMyClass(nil).Multiply;
end;
----
+
Unfortunately, you need to write ugly `@TMyClass(nil).Add` instead of just `@TMyClass.Add`.

* A (possibly) local routine: declare with `is nested` at the end, and make sure to use `{$modeswitch nestedprocvars}` directive for the code. These go hand-in-hand with <<Local (nested) routines>>.

### Generics

A powerful feature of any modern language. The definition of something (typically, of a class) can be parameterized with another type. The most typical example is when you need to create a container (a list, dictionary, tree, graph...): you can define _a list of type T_, and then _specialize_ it to instantly get _a list of integers_, _a list of strings_, _a list of TMyRecord_, and so on.

The generics in Pascal are realized much like generics in C++. Which means that they are "expanded" at the specialization time, a _little_ like macros (but when expanding, the identifiers from the generic definition are used, so you cannot "inject" any unexpected behavior into a generic when specializing it). In effect this means that they are very fast (can be optimized for each particular type)  and work with types of any size. You can use a primitive type (integer, float) as well as a record as well as a class when specializing a generic.
// Unlike in Java, you are *not* limited to only generics of things that are a reference.

[source,pascal]
----
include::code-samples/generics.lpr[]
----

Generics are not limited to classes, you can have generic functions and procedures as well:

[source,pascal]
----
include::code-samples/generic_functions.lpr[]
----

### Overloading

Methods (and global functions and procedures) with the same name are allowed, as long as they have different parameters. At compile time, the compiler detects which one you want to use, knowing the parameters you pass.

By default, the overloading uses the FPC approach, which means that all the methods in given namespace (a class or a unit) are equal, and hide the other methods in namespaces with less priority. For example, if you define a class with methods `Foo(Integer)` and `Foo(string)`, and it descends from a class with method `Foo(Float)`, then the users of your new class will not be able to access the method `Foo(Float)` easily (they still can --- if they typecast the class to it's ancestor type). To overcome this, use the `overload` keyword.

### Preprocessor

You can use simple preprocessor directives for

* conditional compilation (code depending on platform, or some custom switches),
* to include one file in another,
* you can also use parameter-less macros.

Note that macros with parameters are not allowed. In general, you should avoid using the preprocessor stuff... unless it's really justified. The preprocessing happens before parsing, which means that you can "break" the normal syntax of the Pascal language. This is a powerful, but also somewhat dirty, feature.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit PreprocessorStuff;
interface

{$ifdef FPC}
{ This is only defined when compiled by FPC, not other compilers (like Delphi). }
procedure Foo;
{$endif}

{ Define a NewLine constant. Here you can see how the normal syntax of Pascal
  is "broken" by preprocessor directives. When you compile on Unix
  (includes Linux, Android, Mac OS X), the compiler sees this:

    const NewLine = #10;

  When you compile on Windows, the compiler sees this:

    const NewLine = #13#10;

  On other operating systems, the code will fail to compile,
  because a compiler sees this:

    const NewLine = ;

  It's a *good* thing that the compilation fails in this case -- if you
  will have to port the program to an OS that is not Unix, not Windows,
  you will be reminded by a compiler to choose the newline convention
  on that system. }

const
  NewLine =
    {$ifdef UNIX} #10 {$endif}
    {$ifdef MSWINDOWS} #13#10 {$endif} ;

{$define MY_SYMBOL}

{$ifdef MY_SYMBOL}
procedure Bar;
{$endif}

{$define CallingConventionMacro := unknown}
{$ifdef UNIX}
  {$define CallingConventionMacro := cdecl}
{$endif}
{$ifdef MSWINDOWS}
  {$define CallingConventionMacro := stdcall}
{$endif}
procedure RealProcedureName; CallingConventionMacro; external 'some_external_library';

implementation

{$include some_file.inc}
// $I is just a shortcut for $include
{$I some_other_file.inc}

end.
----

Include files have commonly the `.inc` extension, and are used for two purposes:

* The include file may only contain other compiler directives, that "configure" your source code. For example you could create a file `myconfig.inc` with these contents:
+
[source,pascal]
----
{$mode objfpc}
{$H+}
{$J-}
{$modeswitch advancedrecords}
{$ifndef VER3}
  {$error This code can only be compiled using FPC version at least 3.x.}
{$endif}
----
+
Now you can include this file using `{$I myconfig.inc}` in all your sources.

* The other common use is to split a large unit into many files, while still keeping it a single unit as far as the language rules are concerned. Do not overuse this technique -- your first instinct should be to split a single unit into multiple units, not to split a single unit into multiple include files. Never the less, this is a useful technique.
  . It allows to avoid "exploding" the number of units, while still keeping your source code files short. For example, it may be better to have a single unit with _"commonly used UI controls"_ than to create _one unit for each UI control class_, as the latter approach would make the typical "uses" clause long (since a typical UI code will depend on a couple of UI classes). But placing all these UI classes in a single `myunit.pas` file would make it a long file, unhandy to navigate, so splitting it into multiple include files may make sense.
//For example, *Castle Game Engine* has a unit `CastleControls` with a couple of user-interface controls, like `TCastleButton`, `TCastleLabel`, `TCastleImageControl` and more. We could split it into many units, even to _one unit per class_, as the classes are not really tightly connected. But that would often force you to have a long `uses` clause, since a lot of user-interface code will want to use a couple of control classes. So we made a practical decision to just put all _often used controls_ in a single unit.
  . It allows to have a cross-platform unit interface with platform-dependent implementation easily. Basically you can do
+
[source,pascal]
----
{$ifdef UNIX} {$I my_unix_implementation.inc} {$endif}
{$ifdef MSWINDOWS} {$I my_windows_implementation.inc} {$endif}
----
+
Sometimes this is better than writing a long code with many `{$ifdef UNIX}`, `{$ifdef MSWINDOWS}` intermixed with normal code (variable declarations, routine implementation). The code is more readable this way. You can even use this technique more aggressively, by using the `-Fi` command-line option of FPC to include some subdirectories only for specific platforms. Then you can have many version of include file `{$I my platform_specific_implementation.inc}` and you simply include them, letting the compiler find the correct version.

### Records

_Record_ is just a container for other variables. It's like a much, much simplified _class_: there is no inheritance or virtual methods. It is like a _structure_ in C-like languages.

If you use the `{$modeswitch advancedrecords}` directive, records *can* have methods and visibility specifiers. In general, language features that are available for classes, and _do not break the simple predictable memory layout of a record_, are then possible.

[source,pascal]
----
include::code-samples/records.lpr[]
----

In modern Object Pascal, your first instinct should be to design a `class`, not a `record` -- because classes are packed with useful features, like constructors and inheritance.
But records are still very useful when you need speed or a predictable memory layout:

* Records do not have any constructor or destructor. You just define a variable of a record type. It has undefined contents (memory garbage) at the beginning (except auto-managed types, like strings; they are guaranteed to be initialized to be empty, and finalized to free the reference count). So you have to be more careful when dealing with records, but it gives you some performance gain.
* Arrays of records are nicely linear in memory, so they are cache-friendly.
* The memory layout of records (size, padding between fields) is clearly defined in some situations: when you request the _C layout_, or when you use `packed record`. This is useful:
** to communicate with libraries written in other programming languages, when they expose an API based on records,
** to read and write binary files,
** to make dirty low-level tricks (like unsafe typecasting one type to another, being aware of their memory representation).
* Records can also have `case` parts, which work like _unions_ in C-like languages. They allows to treat the same memory piece as a different type, depending on your needs. As such, this allows for greater memory efficiency in some cases. And it allows for more _dirty, low-level unsafe tricks_:)

### Old-style objects

In the old days, Turbo Pascal introduced another syntax for class-like functionality, using the `object` keyword. It's somewhat of a blend between the concept of a `record` and a modern `class`.

* The old-style objects can be allocated / freed, and during that operation you can call their constructor / destructor.
* But they can also be simply declared and used, like records. A simple `record` or `object` type is not a reference (pointer) to something, it's simply the data. This makes them comfortable for small data, where calling allocation / free would be bothersome.
//It also makes them fast -- a list of such structures is nicely linear in memory, iterating over it doesn't involve jumping over pointers. Also, their memory layout is defined in _some_ situations (packed records, or records with C layout), which makes them suitable to pass to external APIs, like OpenGL.
* Old-style objects offer inheritance and virtual methods, although with small differences from the modern classes. Be careful -- _bad things_ will happen if you try to use an object without calling it's constructor, and the object has virtual methods.

It's discouraged to use the old-style objects in most cases. Modern _classes_ provide much more functionality. And when needed, records (including _advanced records_) can be used for performance. These concepts are usually a better idea than old-style objects.

### Pointers

You can create a _pointer_ to any other type. The pointer to type `TMyRecord` is declared as `^TMyRecord`, and by convention is called `PMyRecord`. This is a traditional example of a linked list of integers using records:

[source,pascal]
----
type
  PMyRecord = ^TMyRecord;
  TMyRecord = record
    Value: Integer;
    Next: PMyRecord;
  end;
----

Note that the definition is recursive (type `PMyRecord` is defined using type `TMyRecord`, while `TMyRecord` is defined using `PMyRecord`). It is allowed to define a pointer type to a _not-yet-defined type_, as long as it will be resolved within the same `type` block.

You can allocate and free pointers using the `New` / `Dispose` methods, or (more low-level, not type-safe) `GetMem` / `FreeMem` methods. You dereference the pointer (to access the stuff _pointed by_) you append the `^` operator. To make the inverse operation, which is to _get a pointer of an existing variable_, you prefix it with `@` operator.

There is also an untyped `Pointer` type, similar to `void*` in C-like languages. It is completely unsafe, and can be typecasted to any other pointer type.

Remember that a _class instance_ is also in fact a pointer, although it doesn't require any `^` or `@` operators to use it.
//That's why it's called a _reference_.
A linked list using classes is certainly possible, it would simply be this:

[source,pascal]
----
type
  TMyClass = class
    Value: Integer;
    Next: TMyClass;
  end;
----

### Operator overloading

You can override the meaning of many language operators, for example to allow addition and multiplication of your custom types. Like this:

[source,pascal]
----
include::code-samples/operator_overloading.lpr[]
----

You can override operators on classes too. Since you usually create new instances of your classes inside the operator function, the caller must remember to free the result.

[source,pascal]
----
include::code-samples/operator_overloading_classes.lpr[]
----

You can override operators on records too. This is usually easier than overloading them for classes, as the caller doesn't have to deal then with memory management.

[source,pascal]
----
include::code-samples/operator_overloading_records.lpr[]
----

For records, it's adviced to use `{$modeswitch advancedrecords}` and override operators as `class operator` inside the record. This allows to use generic classes that depend on some operator existence (like `TFPGList`, that depends on equality operator being available) with such records. Otherwise the "global" definition of an operator (not inside the record) would not be found (because it's not available at the code that implements the `TFPGList`), and you could not specialize a list like `specialize TFPGList<TMyRecord>`.

[source,pascal]
----
include::code-samples/operator_overloading_records_lists.lpr[]
----

## Advanced classes features

### private and strict private

The `private` visibility specifier means that the field (or method) is not accessible outside of this class. But it allows an exception: all the code defined _in the same unit_ can break this, and access private fields and methods. A C++ programmer would say that in Pascal _all classes within a single unit are friends_. This is often useful, and doesn't break your encapsulation, since it's limited to a unit.

However, if you create larger units, with many classes (that are not tightly integrated with each other), it's safer to use `strict private`. As you can guess, it means that the field (or method) in not accessible outside of this class -- period. No exceptions.

In a similar manner, there's `protected` visibility (visible to descendants, or friends in the same unit) and `strict protected` (visible to descendants, period).

### Class methods

These are methods you can call having a class reference (`TMyClass`), not necessarily a class instance.

[source,pascal]
----
type
  TEnemy = class
    procedure Kill;
    class procedure KillAll;
  end;

var
  E: TEnemy;
begin
  E := TEnemy.Create;
  try
    E.Kill;
  finally FreeAndNil(E) end;
  TEnemy.KillAll;
end;
----

Note that they can be virtual -- it makes sense, and is sometimes very useful, when combined with <<Class references>>.

Note that a constructor always acts like a class method when called in a normal fashion (`MyInstance := TMyClass.Create(...);`). Although it's possible to also call a constructor from within the class itself, like a normal method, and then it acts like a normal method. This is a useful feature to "chain" constructors, when one constructor (e.g. overloaded to take an integer parameter) does some job, and then calls another constructor (e.g. parameter-less).

### More stuff inside classes and nested classes

You can open a section of constants (`const`) or types (`type`) within a class. This way, you can even define a class within a class. The visibility specifiers work as always, in particular the nested class can be private (not visible to the outside world), which is often useful.
//The compiler watches that you don't break the visibility rules (for example you cannot declare a _public function_ that returns a type that is _private_).
// (I wish - it doesn't, unfortunately...)

Note that to declare a field after a constant or type you will need to open a `var` block.

[source,pascal]
----
type
  TMyClass = class
  private
    type
      TInternalClass = class
        Velocity: Single;
        procedure DoSomething;
      end;
    var
    FInternalClass: TInternalClass;
  public
    const
      DefaultVelocity = 100.0;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TMyClass.Create;
begin
  inherited;
  FInternalClass := TInternalClass.Create;
  FInternalClass.Velocity := DefaultVelocity;
  FInternalClass.DoSomething;
end;

destructor TMyClass.Destroy;
begin
  FreeAndNil(FInternalClass);
  inherited;
end;

{ note that method definition is prefixed with
  "TMyClass.TInternalClass" below. }
procedure TMyClass.TInternalClass.DoSomething;
begin
end;
----

### Class references

_Class reference_ allows you to choose the class at runtime, for example to call a class method or constructor without knowing the exact class at compile-time. It is a type declared as `class of TMyClass`.

[source,pascal]
----
type
  TMyClass = class(TComponent)
  end;

  TMyClass1 = class(TMyClass)
  end;

  TMyClass2 = class(TMyClass)
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  // Obviously you can do this:

  C := TMyClass.Create(nil); FreeAndNil(C);
  C := TMyClass1.Create(nil); FreeAndNil(C);
  C := TMyClass2.Create(nil); FreeAndNil(C);

  // In addition, using class references, you can also do this:

  ClassRef := TMyClass;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass1;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass2;
  C := ClassRef.Create(nil); FreeAndNil(C);
end;
----

Class references can be combined with virtual class methods. This gives a similar effect as using classes with virtual methods -- the actual method to be executed is determined at runtime.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    class procedure DoSomething; virtual; abstract;
  end;

  TMyClass1 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClass2 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  ClassRef := TMyClass1;
  ClassRef.DoSomething;

  ClassRef := TMyClass2;
  ClassRef.DoSomething;

  { And this will cause an exception at runtime,
    since DoSomething is abstract in TMyClass. }
  ClassRef := TMyClass;
  ClassRef.DoSomething;
end;
----

If you have an instance, and you would like to get a reference to it's class (not the declared class, but the final descendant class used at its construction), you can use the `ClassType` property. The declared type of `ClassType` is `TClass`, which stands for `class of TObject`. Often you can safely typecast it to something more specific, when you know that the instance is something more specific than `TObject`.

In particular, you can use the `ClassType` reference to call virtual methods, including virtual constructors. This allows you to create a method like `Clone` that constructs an instance of _the exact run-time class of the current object_. You can combine it with <<Cloning: TPersistent.Assign>> to have a method that returns a newly-constructed clone of the current instance.

Remember that it only works when the constructor of your class is virtual. For example, it can be used with the standard `TComponent` descendants, since they all must override `TComponent.Create(AOwner: TComponent)` virtual constructor.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    procedure Assign(Source: TPersistent); override;
    function Clone(AOwner: TComponent): TMyClass;
  end;

  TMyClassRef = class of TMyClass;

function TMyClass.Clone(AOwner: TComponent): TMyClass;
begin
  // This would always create an instance of exactly TMyClass:
  //Result := TMyClass.Create(AOwner);
  // This can potentially create an instance of TMyClass descendant:
  Result := TMyClassRef(ClassType).Create(AOwner);
  Result.Assign(Self);
end;
----

// This is an example why compiler cannot detect *all* uses of an abstract
// methods at compile time, in this case --- the error can only resurface
// at runtime.
//
// Poor example actually, since compiler could prevent "ClassRef := TMyClass"
// in this case?

### Class helpers (помощники для класса)

_Метод (method)_ является лишь процедурой внутри конкретного класса. Извне класса он вызывается с помощью специального синтаксиса `MyInstance.MyMethod(...)`. И через некоторое время приходит привычка, что _если нужно произвести действие над классом X, следует писать `X.Action(...)`_.

Однако, иногда возникает необходимость выполнить что-либо, что концептуально является _действием на класс TMyClass_, однако при этом не изменяя исходный код _TMyClass_. Причин тому может быть несколько. Например, это может быть исходный код, написанный другим программистом, который не следует или невозможно изменять. Также иногда причиной тому могут быть зависимости -- добавление метода `Render` к классу `TMy3DObject` кажется вполне логичным, однако, возможно, имплементация класса `TMy3DObject` должна быть независимой от кода рендера? В таких случаях удобнее "расширить" существующий класс, добавив к нему функционал, при этом не изменяя его исходный код.

Наиболее простой путь сделать это - создать глобальную процедуру, которая будет принимать ссылку на `TMy3DObject` как параметр.

[source,pascal]
----
procedure Render(const O: TMy3DObject; const Color: TColor);
var
  I: Integer;
begin
  for I := 0 to O.ShapesCount - 1 do
    RenderMesh(O.Shape[I].Mesh, Color);
end;
----

И это действительно сработает. Однако, недостаток такого подхода - он выглядит не очень красиво. Ведь обычно мы вызываем действия над объектом с помощью `X.Action(...)`, а тут нам приходится использовать иной синтаксис: `Render(X, ...)`. Было бы куда удобнее записать `X.Render(...)`, даже для случаев, когда `Render` не описан в unit-е, в котором находится `TMy3DObject`.

Для этого и существуют class helpers, дающие возможность создать процедуры/функции, которые оперируют данным классом и вызываются так как и остальные методы класса, однако не являются "обычными" методами -- они добавляются извне определения класса `TMy3DObject`.

[source,pascal]
----
type
  TMy3DObjectHelper = class helper for TMy3DObject
    procedure Render(const Color: TColor);
  end;

procedure TMy3DObjectHelper.Render(const Color: TColor);
var
  I: Integer;
begin
  // note that we access ShapesCount, Shape without any qualifiers here
  for I := 0 to ShapesCount - 1 do
    RenderMesh(Shape[I].Mesh, Color);
end;
----

ЗАМЕТКА: Более общяя концепция является _"type helper"_, используя которую становится возможным добавлять методы даже к самым примитивным типам, например integer. Можно даже создать _"record helpers_" чтобы... ну, Вы поняли. Детальнее см. здесь: http://lists.freepascal.org/fpc-announce/2013-February/000587.html .
//And of course to records and old-style objects (both of them can also have regular methods, they are much like classes in this regard).

### Virtual constructors, destructors

Destructor name is always `Destroy`, it is virtual (since you can call it without knowing the exact class at compile-time) and parameter-less.

Constructor name is by convention `Create`.

You can change this name, although be careful with this -- if you define `CreateMy`, always redefine also the name `Create`, otherwise the user can still access the constructor `Create` of the ancestor, bypassing your `CreateMy` constructor.

In the base `TObject` it is not virtual, and when creating descendants you're free to change the parameters. The new constructor will hide the constructor in ancestor (note: don't put here `overload`, unless you want to break it).

In the `TComponent` descendants, you should override it's `constructor Create(AOwner: TComponent);`. For streaming functionality, to create a class without knowing it's type at compile time, having virtual constructors is very useful (see "class references" below).

### An exception in constructor

What happens if an exception happens during a constructor? The line

[source,pascal]
----
X := TMyClass.Create;
----

does not execute to the end in this case, `X` cannot be assigned, so who will cleanup after a partially-constructed class?

The solution of Object Pascal is that, in case an exception occurs within a constructor, then the destructor is called. This is a reason why _your destructor must be robust_, which means it should work in any circumstances, even on half-created class instance. Usually this is easy if you release everything safely, like by `FreeAndNil`.

We also have to depend in such cases that _the memory of the class is guaranteed to be zeroed right before the constructor code is executed_. So we know that at the beginning, all class references are `nil`, all integers are `0` and so on.

So below works without any memory leaks:

[source,pascal]
----
include::code-samples/exception_in_constructor_test.lpr[]
----

## Интерфейсы

### Хорошие (CORBA) интерфейсы

_Интерфейс_ объявляет API, так же как и класс, но он не определяет реализацию(implementation). Класс может выполнять множество интерфейсов, но он может иметь только один класс-предок.

Вы можете привести класс к любому интерфейсу, его поддерживающий,и тогда _вызывать методы через этот интерфейс_. Это позволяет обрабатывать классы единообразно, которые не происходят друг от друга, но которые имеют общие функциональные возможности. Полезно когда не хватает простого наследования классов.

 _Интерфейсы CORBA_ в Object Pascal работают в значительной степени так, как и интерфейсы в Java (https://docs.oracle.com/javase/tutorial/java/concepts/interface.html) или в C# (https://msdn.microsoft.com/en-us/library/ms173156.aspx).

//Это очень похоже на Java, когда интерфейсы используются, в тот момент, когда бы ты думал о множественном наследовании.
[source,pascal]
----
include::code-samples/interfaces_corba_test.lpr[]
----

### CORBA и COM интерфейсы

Почему интерфейсы (показанные выше) названны "CORBA"?::

  The name *CORBA* is unfortunate. A better name would be *bare interfaces*. These interfaces are a _"pure language feature"_. Use them when you want to cast various classes as the same interface, because they share a common API.
+
//The declaration `{$interface corba}` simply means that the declared interfaces *do not* automatically descend from the special `IUnknown` interface. Which in turn means that they *do not* by default have any extra baggage (like reference-counting found in the *COM* interfaces).
//+
While these types of interfaces can be used together with the _CORBA (Common Object Request Broker Architecture) technology_ (see https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture), they are _not_ tied to this technology in any way.

Is the `{$interfaces corba}` declaration needed?::

  Yes, because by default
//(if we would omit the `{$interfaces corba}` directive)
  you create _COM interfaces_. This can be stated explicitly by saying `{$interfaces com}`, but usually it's not needed since it's the default state.
+
And I don't advice using _COM interfaces_. Especially if you know interfaces from other programming languages. The _CORBA interfaces_ in Pascal are exactly what you expect, equal to the interfaces in C# and Java. While the _COM interfaces_ bring additional "features" that you probably don't want.
+
Note that the `{$interfaces xxx}` declaration only affects the interfaces that do not have any explicit ancestor (just the keyword `interface`, not `interface(ISomeAncestor)`). When an interface has an ancestor, it has the same type as the ancestor, regardless of the `{$interfaces xxx}` declaration.

What are COM interfaces?::

  The _COM interface_ is synonymous with _an interface descending from a special `IUnknown` interface_. Descending from `IUnknown`:
+
* Requires that your classes define the `_AddRef` and `_ReleaseRef` methods. Proper implementation of these methods can manage the lifetime of your objects using the reference-counting.
* Adds the `QueryInterface` method.
* Allows to interact with the _COM (Component Object Model) technology_.

What do you advice to not use the COM interfaces?::

  The additional features brought by the COM interfaces are rather problematic in my view. Don't get me wrong -- the idea of reference-counting is very nice. But entangling these features with interfaces (instead of making them orthogonal features) is very unclean in my eyes. It definitely doesn't match my use cases.
+
--
* Sometimes I want to cast my (otherwise unrelated) classes to a common interface.
* Sometimes I want to manage memory using the reference counting approach.
* _Maybe_ some day I will want to interact with the _COM technology_.
--
+
But these are all separate, unrelated needs. Entangling them in a single language feature is counter-useful in my experience. And it does cause actual problems: the reference-counting mechanism of COM, even when disabled by a special `_AddRef` and `_ReleaseRef` implementation, is still troublesome. You still need to be careful to never have a temporary interface reference hanging, after you have freed the class instance. More details about it in the next section.
+
That is why I advice to use _CORBA_ style interfaces, and the `{$interfaces corba}` directive, in all modern code dealing with interfaces. The _COM_ interfaces are somewhat an _embarrassment to the language_, in my eyes.
+
To be fair, the _COM interfaces_ are presented in more details in the next section anyway.

Can we have reference-counting with CORBA interfaces?::

  Yeah. Just add `_AddRef` / `_ReleaseRef` methods. There's no need to descend from the `IUnknown` interface. Although in most cases, if you want reference-counting with your interfaces, you may as well just use COM interfaces.
//    Stress that non reference counted interfaces are more "bare" and deemphasize the link to corba and java. Note that iunknown doesn't just do refcounting though, it also plays a part in identity (queryinterface) that allows to get other interfaces supported by the object from the object. (e.g. to see if you can "upcast" an interface to a newer version)
//  Roger. The way I understand, the better names would be "always-descend-from-IUnknown" vs "don't-always-descend-from-iUnknown", not "COM" vs "CORBA". That would certainly be clearer for someone who is not interested in interacting with outside services (neither COM nor CORBA) and just wants a language feature (with the purpose of casting two classes to a common interface, because they share a common API, similar to interfaces in Java/C#).

### Interfaces GUIDs

GUIDs are the seemingly random characters `['{ABCD1234-...}']` that you see placed at every interface definition. Yes, they are just random. Unfortunately, they are necessary.

//Yes, they look ugly.
//, and I wish they would not be necessary.
They have no meaning (if you don't plan on integrating with communication technologies like _COM_ nor _CORBA_). But they are necessary, for implementation reasons. Don't be fooled by the compiler, that unfortunately allows you to declare interfaces without GUIDs.

Without the (unique) GUIDs, your interfaces will be treated equal by the `is` operator. In effect, it will return `true` if your class supports _any_ of your interfaces. The magic function `Supports(ObjectInstance, IMyInterface)` behaves slightly better here, as it refuses to be compiled for interfaces without a GUID. This is true for both CORBA and COM interfaces, as of FPC 3.0.0.

So, to be on the safe side, you should always declare a GUID for your interface. You can use _Lazarus_ GUID generator (`Ctrl + Shift + G` shortcut in the editor). Or you can use an online service like https://www.guidgenerator.com/ .

Or you can write your own tool for this, using the `CreateGUID` and `GUIDToString` functions in RTL. See the example below:

[source,pascal]
----
include::code-samples/gen_guid.lpr[]
----

### Ugly (COM) interfaces

The _COM interfaces_ bring two additional features:

. integration with COM (a technology from Windows, also available on Unix through _XPCOM_, used by Mozilla),
. reference counting (which gives you automatic destruction when all the interface references go out of scope).

In my eyes, it was rather ugly to entangle _interfaces_ with such features. It complicates using the interfaces for the simple purpose: when multiple classes implement the same API, but cannot descend from a common class. When using _COM interfaces_, you need to be aware of their _automatic destruction_ mechanism and relation to COM technology.

In practice, this means that:

// +
// The relation to COM technology has . The reference counting idea is baffling. Why would you connect one language feature, _interfaces_, with something so unrelated like _reference counting_? It seems, because the COM technology required it...

* Your class needs to implement a magic `_AddRef`, `_Release`, and `QueryInterface` methods. Or descend from something that already implements them. A particular implementation of these methods may actually enable or disable the __reference-counting__ feature of COM interfaces (although disabling it is somewhat dangerous -- see the next point).

** The standard class `TInterfacedObject` implements these methods to _enable_ the reference-counting.
** The standard class `TComponent` implements these methods to _disable_ the reference-counting. *In the Castle Game Engine* we give you additional useful ancestors `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` for this purpose, see https://github.com/castle-engine/castle-engine/blob/master/src/base/castleinterfaces.pas .

//* You can turn off the reference-counting mechanism by simple `_AddRef`, `_Release` implementations that always return `-1`. Actually, the standard implementation of these methods in `TComponent`, `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` already does this for you.

* You need to be careful of freeing the class, when it may be referenced by some interface variables. Because the interface is released using a virtual method (because it _may be reference-counted, even if you hack the _AddRef method to not be reference-counted..._), you cannot free the underlying object instance as long as some interface variable may point to it. See _"7.7 Reference counting"_ in the FPC manual (http://freepascal.org/docs-html/ref/refse47.html).
//, http://bugs.freepascal.org/view.php?id=10374 .

The safest approach to using _COM interfaces_ is to

* accept the fact that they are reference-counted,
* derive the appropriate classes from `TInterfacedObject`,
* and avoid using the class instance, instead accessing the instance always through the interface, letting reference-counting manage the deallocation.

This is an example of such interface use:

[source,pascal]
----
include::code-samples/interfaces_com_with_ref_counting.lpr[]
----

### Using COM interfaces with reference-counting disabled

As mentioned in the previous section, your class can descend from `TComponent` (or a similar class like `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent`) which disables reference-counting for COM interfaces. This allows you to use COM interfaces, and still free the class instance manually.

You need to be careful in this case to not free the class instance when some interface variable may refer to it. Remember that every typecast `Cx as IMyInterface` also creates a temporary interface variable, which may be present even until the end of the current procedure. For this reason, the example below uses a `UseInterfaces` procedure, and it frees the class instances _outside_ of this procedure (when we can be sure that temporary interface variables are out of scope).

To avoid this mess, it's usually better to use CORBA interfaces, if you don't want reference-counting with your interfaces.

[source,pascal]
----
include::code-samples/interfaces_com_test.lpr[]
----

### Typecasting interfaces without "as" operator

This section applies to both _CORBA_ and _COM_ interfaces.

Casting to an interface type using the `as` operator makes a check at run-time. Consider this code:

[source,pascal]
----
UseThroughInterface(Cx as IMyInterface);
----

It works for all `C1`, `C2`, `C3` instances in the examples in previous sections. If executed, it would make a run-time error in case of `C3`, that does not implement `IMyInterface` (but we avoid the error by checking `Cx is IMyInterface` before doing the cast).

You can instead cast the instance as an interface implicitly:

[source,pascal]
----
UseThroughInterface(Cx);
----

In this case, the typecast must be valid at compile-time. So this will compile for `C1` and `C2` (that are declared as classes that implement `IMyInterface`).

But it will not compile for `C3`.

In essence, this typecast looks and works just like for regular classes. Wherever an instance of a class `TMyClass` is required, you can always use there a variable that is declared with a class of `TMyClass`, *or `TMyClass` descendant*. The same rule applies to interfaces. No need for any explicit typecast in such situations.

An equivalent is also

[source,pascal]
----
UseThroughInterface(IMyInterface(Cx));
----

This is also a typecast that must be valid at compile-time. Note that this syntax is inconsistent with classes typecasts. In case of classes, writing `TMyClass\(C)` is an _unsafe, unchecked_ typecast. In case of interfaces, writing `IMyInterface\(C)` is a safe, fast (checked at compile-time) typecast.

## Про этот документ

Copyright Michalis Kamburelis.

Исходные файлы этого документа в формате AsciiDoc можно скачать по адресу: https://github.com/michaliskambi/modern-pascal-introduction .
Автор будет рад любым пожеланиям, исправлениям, расширениям материала, доработкам и pull request-ам :). С автором можно связаться через профиль GitHub либо по e-mail: michalis.kambi@gmail.com . Домашняя страничка автора: https://michalis.ii.uni.wroc.pl/~michalis/ .

Этот документ можно свободно распространять и изменять на лицензи идентичной лицензии Wikipedia https://en.wikipedia.org/wiki/Wikipedia:Copyrights :

* _Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA)_
* Либо _GNU Free Documentation License (GFDL) (unversioned, with no invariant sections, front-cover texts, or back-cover texts)_ .

Благодарю за прочтение!

Перевод на русский выполнен:
Александр Скворцов и Евгений Лоза
2016.
